import numpy as np

# numpy 广播机制
# 文章1：https://zhuanlan.zhihu.com/p/402163854
# 文章2：https://zhuanlan.zhihu.com/p/262166150

'''
广播的原则：

如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符，
或其中的一方的长度为1，则认为它们是广播兼容的。
广播会在缺失和（或）长度为1的维度上进行。

这句话乃是理解广播的核心，但是文字的定义还是比较难以理解。
这里通俗的解释一下就是广播机制可以在两种情况下作用，
一种是两个数组的维数不相等，
但是它们的后缘维度的轴长相符（其实就是从后数的连续若干个维度数都相同），
另外一种是有一方的长度为1（其实就是如果从后数有维度不同，但是维度大小为1时，广播机制同样可以发挥作用）。

所输入的数组会向其中形状最长的数组看齐，形状中不足的部分都通过在前面（左侧）补1
'''

# 案例1
a1 = np.array([
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
])
b1 = np.array([1, 2, 3])
'''
执行：a1+b1

a1.shape = [4,3]
b1.shape =   [3]

检查发现，从后缘维度起，a1和b1，都是3，符合“相同或为一”的规则
a1.shape = [4,3]
b1.shape =   [3]

检查发现，从后缘维度起，b1的形状不足，b1往前补1，b1数组发生变化
b1 = [
    [1,2,3]
]
a1.shape = [4,3]
b1.shape = [1,3]

检查发现，从后缘维度起，a1是4，b1是1，符合“相同或为一”的规则。为1的一方，向不为1的一方看齐。a1是4，b1是1，b1变成4。b1数组发生变化
b1 = [
    [1,2,3],
    [1,2,3],
    [1,2,3],
    [1,2,3]
]
a1.shape = [4,3]
b1.shape = [4,3]

检查发现，a1和b1形状相同，可以运算，运算结果是：
[[1 2 3]
 [1 2 3]
 [1 2 3]
 [1 2 3]]
'''


# 案例2
a2 = np.array([
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ],
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ],
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ]
])
b2 = np.array([
    [1, 2],
    [3, 4],
    [5, 6],
    [7, 8]
])
'''
执行：a2+b2

a2.shape = [3,4,2]
b2.shape =   [4,2]

检查发现，从后缘维度起，a2和b2，都是2，符合“相同或为一”的规则
a2.shape = [3,4,2]
b2.shape =   [4,2]

检查发现，从后缘维度起，a2和b2，都是4，符合“相同或为一”的规则
a2.shape = [3,4,2]
b2.shape =   [4,2]

检查发现，从后缘维度起，b2的形状不足，b2往前补1，b2数组发生变化
b2 = [
    [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8]
    ]
]
a2.shape = [3,4,2]
b2.shape = [1,4,2]

检查发现，从后缘维度起，a2是3，b2是1，符合“相同或为一”的规则。为1的一方，向不为1的一方看齐。a2是3，b2是1，b2变成3。b2数组发生变化
b2 = [
    [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8]
    ],
    [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8]
    ],
    [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8]
    ]
]
a2.shape = [3,4,2]
b2.shape = [3,4,2]

检查发现，a2和b2形状相同，可以运算，运算结果是：
[[[1 2]
  [3 4]
  [5 6]
  [7 8]]

 [[1 2]
  [3 4]
  [5 6]
  [7 8]]

 [[1 2]
  [3 4]
  [5 6]
  [7 8]]]
'''

# 案例3
a3 = np.array([
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]
])
b3 = np.array([
    [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ],
    [
        [10, 11, 12],
        [13, 14, 15],
        [16, 17, 18]
    ]
])
'''
执行：a3+b3

a3.shape = [4,3,3]
b3.shape = [2,3,3]

检查发现，从后缘维度起，a3和b3，都是3，符合“相同或为一”的规则
a3.shape = [4,3,3]
b3.shape = [2,3,3]

检查发现，从后缘维度起，a3和b3，都是3，符合“相同或为一”的规则
a3.shape = [4,3,3]
b3.shape = [2,3,3]

检查发现，从后缘维度起，a3是4，b3是2，不符合“相同或为一”的规则
所以报错：
ValueError: operands could not be broadcast together with shapes (4,3,3) (2,3,3)
'''

# 案例4
a4 = np.array([
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ]
])
b4 = np.array([
    [
        [1, 2, 3, 4, 5, 6],
    ],
    [
        [7, 8, 9, 10, 11, 12],
    ],
    [
        [13, 14, 15, 16, 17, 18],
    ]
])
'''
执行：a4+b4

a4.shape = [3,3,6]
b4.shape = [3,1,6]

检查发现，从后缘维度起，a4和b4，都是6，符合“相同或为一”的规则
a4.shape = [3,3,6]
b4.shape = [3,1,6]

检查发现，从后缘维度起，a4是3，b4是1，符合“相同或为一”的规则。为1的一方，向不为1的一方看齐。a4是3，b4是1，b4变成3。b4数组发生变化
b4 = np.array([
    [
        [1, 2, 3, 4, 5, 6],
        [1, 2, 3, 4, 5, 6],
        [1, 2, 3, 4, 5, 6]
    ],
    [
        [7, 8, 9, 10, 11, 12],
        [7, 8, 9, 10, 11, 12],
        [7, 8, 9, 10, 11, 12]
    ],
    [
        [13, 14, 15, 16, 17, 18],
        [13, 14, 15, 16, 17, 18],
        [13, 14, 15, 16, 17, 18]
    ]
])
a4.shape = [3,3,6]
b4.shape = [3,3,6]

检查发现，从后缘维度起，a4和b4，都是3，符合“相同或为一”的规则
a4.shape = [3,3,6]
b4.shape = [3,3,6]

检查发现，a4和b4形状相同，可以运算，运算结果是：
[[[ 1  2  3  4  5  6]
  [ 1  2  3  4  5  6]
  [ 1  2  3  4  5  6]]

 [[ 7  8  9 10 11 12]
  [ 7  8  9 10 11 12]
  [ 7  8  9 10 11 12]]

 [[13 14 15 16 17 18]
  [13 14 15 16 17 18]
  [13 14 15 16 17 18]]]
'''

# 案例5
a5 = np.array([
    [0],
    [1],
    [2]
])
b5 = np.array([0,1,2])
'''
执行：a5+b5

a5.shape = [3,1]
b5.shape =   [3]

检查发现，从后缘维度起，a5是1，b5是3，符合“相同或为一”的规则。为1的一方，向不为1的一方看齐。a5是1，b5是3，a5变成3。a5数组发生变化
a5 = [
    [0,0,0],
    [1,1,1],
    [2,2,2]
]
a5.shape = [3,3]
b5.shape =   [3]

检查发现，从后缘维度起，b5的形状不足，b5往前补1，b5数组发生变化
b5 = [
    [0,1,2]
]
a5.shape = [3,3]
b5.shape = [1,3]

检查发现，从后缘维度起，a5是3，b5是1，符合“相同或为一”的规则。为1的一方，向不为1的一方看齐。a5是3，b5是1，b5变成3。b5数组发生变化
b5 = [
    [0,1,2],
    [0,1,2],
    [0,1,2]
]
a5.shape = [3,3]
b5.shape = [3,3]

检查发现，a5和b5形状相同，可以运算，运算结果是：
[[0 1 2]
 [1 2 3]
 [2 3 4]]
'''

