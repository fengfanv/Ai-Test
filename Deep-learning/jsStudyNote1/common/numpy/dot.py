import numpy as np

# 两个数组的点积运算方法（numpy.dot）

# print(help(np.dot))


# 情况1（两边都是 数字）
# print(np.dot(2,3)) # 2*3=6


# 情况2（两边有一边是数字，另一边是数组）
# a = np.array([
#     [
#         [1, 2, 3],
#         [4, 5, 6]
#     ],
#     [
#         [1, 2, 3],
#         [4, 5, 6]
#     ]
# ])

# print(a.shape) # (2, 2, 3)
# result = np.dot(2, a)
# print(result.shape) # (2, 2, 3)
# print(result)
# '''
# [[[ 2  4  6]
#   [ 8 10 12]]

#  [[ 2  4  6]
#   [ 8 10 12]]]
# '''

# result2 = np.dot(a, 2)
# print(result2.shape) # (2, 2, 3)
# print(result2)
# '''
# [[[ 2  4  6]
#   [ 8 10 12]]

#  [[ 2  4  6]
#   [ 8 10 12]]]
# '''

# 以上不难，执行的是乘法，没有进行点积运算 --------------------------------

# 情况3（两数组都是1维）
# a = np.array([1,2,3])
# b = np.array([1,2,3])
# c = np.array([1,2,3,4])
# d = np.array([1])
# print(np.dot(a,b)) # 14 = 1*1+2*2+3*3

# print(np.dot(a,c)) # 报错

# print(np.dot(a,d)) # 报错

# 以上不难， 点积运算---------------------------------------------------

# 情况4（书上的内容）（两个数组中，最低维，是1维）
# a = np.array([1, 2, 3])
# b = np.array([
#     [1, 2],
#     [1, 2],
#     [1, 2]
# ])
# b1 = np.array([
#     [
#         [
#             [1, 2],
#             [1, 2],
#             [1, 2]
#         ],
#         [
#             [1, 2],
#             [1, 2],
#             [1, 2]
#         ]
#     ],
#     [
#         [
#             [1, 2],
#             [1, 2],
#             [1, 2]
#         ],
#         [
#             [1, 2],
#             [1, 2],
#             [1, 2]
#         ]
#     ]
# ])
# c = np.array([
#     [1, 1, 1],
#     [2, 2, 2],
# ])
# c1 = np.array([
#     [
#         [
#             [
#                 [1, 1, 1],
#                 [2, 2, 2],
#             ]
#         ]
#     ],
#     [
#         [
#             [
#                 [1, 1, 1],
#                 [2, 2, 2],
#             ]
#         ]
#     ]
# ])

# a_b
# print(a.shape) # (3,)
# print(b.shape) # (3, 2)
# a_b = np.dot(a,b)
# print(a_b.shape) # (2,)
# print(a_b)
# [6 12]
# 1*1+2*1+3*1=6
# 1*2+2*2+3*2=12

# b_a
# b_a = np.dot(b,a) # 报错

# c_a
# print(c.shape) # (2, 3)
# print(a.shape) # (3,)
# c_a = np.dot(c, a)
# print(c_a.shape) # (2,)
# print(c_a)
# [6 12]
# 1*1+1*2+1*3=6
# 2*1+2*2+2*3=12

# a_b1
# print(a.shape) # (3,)
# print(b1.shape) # (2, 2, 3, 2)
# a_b1 = np.dot(a, b1)
# print(a_b1.shape) # (2, 2, 2)
# print(a_b1)
# [[[ 6 12]
#   [ 6 12]]

#  [[ 6 12]
#   [ 6 12]]]

# c1_a
# print(c1.shape) # (2, 1, 1, 2, 3)
# print(a.shape) # (3,)
# c1_a = np.dot(c1, a)
# print(c1_a.shape) # (2, 1, 1, 2)
# print(c1_a)
# [[[[ 6 12]]]


#  [[[ 6 12]]]]


# 从下边开始运算逻辑有点不一样了-------------------------------------


# 情况5（书上的内容）（两个数组中，最低维，是2维）
# a = np.array([
#     [1, 2, 3],
#     [4, 5, 6],
# ])
# a1 = np.array([
#     [
#         [
#             [1, 2, 3],
#             [4, 5, 6],
#         ],
#         [
#             [7, 8, 9],
#             [10, 11, 12],
#         ]
#     ],
#     [
#         [
#             [13, 14, 15],
#             [16, 17, 18],
#         ],
#         [
#             [19, 20, 21],
#             [22, 23, 24],
#         ]
#     ]
# ])
# a2 = np.array([
#     [
#         [
#             [1, 2, 3],
#         ],
#         [
#             [4, 5, 6],
#         ]
#     ],
#     [
#         [
#             [1, 2, 3],
#         ],
#         [
#             [4, 5, 6],
#         ]
#     ]
# ])
# b = np.array([
#     [1, 4],
#     [2, 5],
#     [3, 6]
# ])
# b1 = np.array([
#     [
#         [1, 4],
#         [2, 5],
#         [3, 6]
#     ],
#     [
#         [7, 10],
#         [8, 11],
#         [9, 12]
#     ],
#     [
#         [13, 16],
#         [14, 17],
#         [15, 18]
#     ]
# ])
# b2 = np.array([
#     [
#         [1],
#         [2],
#         [3]
#     ],
#     [
#         [4],
#         [5],
#         [6]
#     ]
# ])
# c = np.array([
#     [
#         [1, 2],
#         [3, 4],
#     ],
#     [
#         [1, 2],
#         [3, 4],
#     ]
# ])

# a_b
# print(a.shape) # (2, 3)
# print(b.shape) # (3, 2)
# a_b = np.dot(a,b)
# print(a_b.shape) # (2, 2)
# print(a_b)
# [[14 32]
#  [32 77]]

# b_a
# print(b.shape) # (3, 2)
# print(a.shape) # (2, 3)
# b_a = np.dot(b,a)
# print(b_a.shape) # (3, 3)
# print(b_a)
# [[17 22 27]
#  [22 29 36]
#  [27 36 45]]

# 下面的运算逻辑和上边的不一样 ---------------------------

# a1_b
# print(a1.shape)  # (2, 2, 2, 3)
# print(b.shape)  # (3, 2)
# a1_b = np.dot(a1, b)
# print(a1_b.shape)  # (2, 2, 2, 2)
# print(a1_b)
# [[[[ 14  32]
#    [ 32  77]]

#   [[ 50 122]
#    [ 68 167]]]


#  [[[ 86 212]
#    [104 257]]

#   [[122 302]
#    [140 347]]]]
# 1*1+2*2+3*3 = 14
# 1*4+2*5+3*6 = 32
# 4*1+5*2+6*3 = 32
# 4*4+5*5+6*6 = 77
# 7*1+8*2+9*3 = 50
# 7*4+8*5+9*6 = 122
# //...等等
# 在这里发现，两边数组，有一边是二维，一边是三维及以上，运算逻辑也是走的，下面所总结的，两边都是三维及以上的那种运算逻辑。

# a_b1
# print(a.shape) # (2, 3)
# print(b1.shape) # (3, 3, 2)
# a_b1 = np.dot(a, b1)
# print(a_b1.shape) # (2, 3, 2)
# print(a_b1)
# [[[ 14  32]
#   [ 50  68]
#   [ 86 104]]

#  [[ 32  77]
#   [122 167]
#   [212 257]]]
# 1*1+2*2+3*3 = 14
# 1*4+2*5+3*6 = 32
# 1*7+2*8+3*9 = 50
# 1*10+2*11+3*12 = 68
# 1*13+2*14+3*15 = 86
# 1*16+2*17+3*18 = 104
# //...等等
# 在这里发现，两边数组，有一边是二维，一边是三维及以上，运算逻辑也是走的，下面所总结的，两边都是三维及以上的那种运算逻辑。

# a_c
# print(a.shape) # (2, 3)
# print(c.shape) # (2, 2, 2)
# print(np.dot(a,c)) # 报错

# a2_b
# print(a2.shape) # (2, 2, 1, 3)
# print(b.shape) # (3, 2)
# a2_b = np.dot(a2, b)
# print(a2_b.shape) # (2, 2, 1, 2)
# print(a2_b)
# [[[[14 32]]

#   [[32 77]]]


#  [[[14 32]]

#   [[32 77]]]]

# a_b2
# print(a.shape) # (2, 3)
# print(b2.shape) # (2, 3, 1)
# a_b2 = np.dot(a,b2)
# print(a_b2.shape) # (2, 2, 1)
# print(a_b2)
# [[[14]
#   [32]]

#  [[32]
#   [77]]]
# 14 = 1*1+2*2+3*3
# 32 = 1*4+2*5+3*6
# 32 = 4*1+5*2+6*3
# 77 = 4*4+5*5+6*6


# 以上稍稍有点难，但结合dot书一起看，没什么大问题---------------------------------


# 情况6（两个数组中，最低维，是3维）
# a = np.array([
#     [
#         [1, 2, 3],
#         [4, 5, 6],
#     ],
#     [
#         [7, 8, 9],
#         [10, 11, 12],
#     ],
# ])
# a1 = np.array([
#     [
#         [
#             [1, 2, 3],
#             [4, 5, 6],
#         ],
#         [
#             [7, 8, 9],
#             [10, 11, 12],
#         ],
#     ],
#     [
#         [
#             [1, 2, 3],
#             [4, 5, 6],
#         ],
#         [
#             [7, 8, 9],
#             [10, 11, 12],
#         ],
#     ],
# ])
# a2 = np.array([
#     [
#         [1, 2, 3],
#         [4, 5, 6],
#     ],
# ])
# a3 = np.array([
#     [
#         [1, 2, 3],

#     ],
#     [
#         [4, 5, 6],
#     ],
#     [
#         [7, 8, 9],
#     ]
# ])
# b = np.array([
#     [
#         [1, 1],
#         [2, 2],
#         [3, 3],
#     ],
#     [
#         [4, 4],
#         [5, 5],
#         [6, 6],
#     ],
# ])
# b1 = np.array([
#     [
#         [
#             [1, 1],
#             [2, 2],
#             [3, 3],
#         ],
#         [
#             [4, 4],
#             [5, 5],
#             [6, 6],
#         ],
#     ],
#     [
#         [
#             [7, 7],
#             [8, 8],
#             [9, 9],
#         ],
#         [
#             [10, 10],
#             [11, 11],
#             [12, 12],
#         ],
#     ],
#     [
#         [
#             [13, 13],
#             [14, 14],
#             [15, 15],
#         ],
#         [
#             [16, 16],
#             [17, 17],
#             [18, 18],
#         ],
#     ]
# ])

# a_b
# print(a.shape) # (2, 2, 3)
# print(b.shape) # (2, 3, 2)
# a_b = np.dot(a,b)
# print(a_b.shape) # (2, 2, 2, 2)
# print(a_b)
# [[[[ 14  14]
#    [ 32  32]]
#   [[ 32  32]
#    [ 77  77]]]

#  [[[ 50  50]
#    [122 122]]
#   [[ 68  68]
#    [167 167]]]]
# 1*1+2*2+3*3=14
# 1*1+2*2+3*3=14
# 1*4+2*5+3*6=32
# 1*4+2*5+3*6=32

# 4*1+5*2+6*3=32
# 4*1+5*2+6*3=32
# 4*4+5*5+6*6=77
# 4*4+5*5+6*6=77

# 7*1+8*2+9*3=50
# 7*1+8*2+9*3=50
# 7*4+8*5+9*6=122
# 7*4+8*5+9*6=122

# 10*1+11*2+12*3=68
# 10*1+11*2+12*3=68
# 10*4+11*5+12*6=167
# 10*4+11*5+12*6=167

# a2_b
# print(a2.shape) # (1, 2, 3)
# print(b.shape) # (2, 3, 2)
# a2_b = np.dot(a2,b)
# print(a2_b.shape) # (1, 2, 2, 2)
# print(a2_b)
# [[[[14 14]
#    [32 32]]

#   [[32 32]
#    [77 77]]]]

# a3_b
# print(a3.shape) # (3, 1, 3)
# print(b.shape) # (2, 3, 2)
# a3_b = np.dot(a3,b)
# print(a3_b.shape) # (3, 1, 2, 2)
# print(a3_b)
# [[[[ 14  14]
#    [ 32  32]]]


#  [[[ 32  32]
#    [ 77  77]]]


#  [[[ 50  50]
#    [122 122]]]]

# a_b1
# print(a.shape) # (2, 2, 3)
# print(b1.shape) # (3, 2, 3, 2)
# a_b1 = np.dot(a, b1)
# print(a_b1.shape) # (2, 2, 3, 2, 2)
# print(a_b1)
# [[[[[ 14  14]
#     [ 32  32]]

#    [[ 50  50]
#     [ 68  68]]

#    [[ 86  86]
#     [104 104]]]


#   [[[ 32  32]
#     [ 77  77]]

#    [[122 122]
#     [167 167]]

#    [[212 212]
#     [257 257]]]]


#  [[[[ 50  50]
#     [122 122]]

#    [[194 194]
#     [266 266]]

#    [[338 338]
#     [410 410]]]


#   [[[ 68  68]
#     [167 167]]

#    [[266 266]
#     [365 365]]

#    [[464 464]
#     [563 563]]]]]

# 1*1+2*2+3*3=14
# 1*4+2*5+3*6=32
# 1*7+2*8+3*9=50
# 1*10+2*11+3*12=68
# 1*13+2*14+3*15=86
# 1*16+2*17+3*18=104
# ...等等

# a1_b
# print(a1.shape) # (2, 2, 2, 3)
# print(b.shape) # (2, 3, 2)
# a1_b = np.dot(a1,b)
# print(a1_b.shape) # (2, 2, 2, 2, 2)
# print(a1_b)
# [[[[[ 14  14]
#     [ 32  32]]

#    [[ 32  32]
#     [ 77  77]]]


#   [[[ 50  50]
#     [122 122]]

#    [[ 68  68]
#     [167 167]]]]


#  [[[[ 14  14]
#     [ 32  32]]

#    [[ 32  32]
#     [ 77  77]]]


#   [[[ 50  50]
#     [122 122]]

#    [[ 68  68]
#     [167 167]]]]]


'''
经过观察，numpy.dot两边都三维及以上数组的运算案例，得出以下结论：
numpy.dot多维数组运算（两个数组，都是三维及以上）
运算方式：
左边数组里的 每一行 都乘一遍 右边数组里所有的二维矩阵。
如，当左边数组里的第一行数据，乘完一遍，右边数组里 所有的二维矩阵后，
左边数组里的第二行数据，乘，右边数组里所有的二维矩阵。
当左边数组里第二行数据，乘完一遍，右边数组里所有的二维矩阵后，
左边第三行数据，开始乘，右边数组里所有的二维矩阵，以此类推 或 重复这种操作，
直到左边数组里所有的行，都乘过一遍右边数组里所有的二维矩阵后，结束运算。

---

因为这种运算方式，所以两边都是三维及以上的计算结果数组，是已左边数组的每一行为基础，
然后再加上右边整个数组的形状，得出运算结果形状。

如：
根据形状观察如下案例：
a = np.arange(3*4*5*6).reshape(3,4,5,6)
b = np.arange(3*4*5*6).reshape(5,4,6,3)
result = np.dot(a, b)
print(result.shape) # (3, 4, 5, 5, 4, 3)
a.shape (3,4,5,6)
b.shape (5,4,6,3)
result.shape (3,4,5,5,4,3)
这里a和b运算得出的结果数组形状的前三位 (3,4,5 就是 a.shape的前三位 (3,4,5 ；
结果数组形状的第四位，第五位（从1开始数的位数） 5,4 就是第二个数组形状 的前两位 (5,4,
然后就有了如下这种情况
a.shape      (3,4,5,6)
b.shape            (5,4,6,3)
result.shape (3,4,5,5,4,  3)
那结果数组形状的最后一维，为啥是3？
运算的时候，第一个数组里的每一行，在与，第二个数组里二维矩阵进行运算的时候，
请将第一个数组里的行，当成一个一维数组，然后乘，第二个数组里的二维数组。第一个数组的一维，乘，第二个数组的二维。

两边都是三维及以上运算，请记住如下定理，第一个数组里的最后一维，乘，第二个数组里倒数第二个维度。

a.shape (3,4,5,6) 的最后一维是 6)，当成一个一维数组的话，就是一个有6个元素的一维数组[6]

b.shape (5,4,6,3) 倒数后两维是，6,3)，当成一个二维数组的话，就是一个，6行3列 的二维矩阵[6,3]

[6] 和 [6,3] 进行dot点积运算，运算的结果数组形状，就是[3]，所以这就是为什么 上边 result.shape (3,4,5,5,4,3) 的最后一维是3。

实际运算时，其实也是这么处理的，第一个数组里的一维，第二个数组里的二维。

上边这样写，是为了更好的快速理解，接下来用js重现的时候，和这个不一样。

'''

# 以上数组两边都是三维及以上，有点麻烦，但能敲出来------------------------------


# 情况7（实验奇葩情况）
# a = np.array([1, 2, 3])
# b = np.array([
#     [1, 2, 3],
# ])
# c = np.array([
#     [1],
#     [2],
#     [3]
# ])
# print(np.dot(a, b)) # 报错，执行不了，幸好执行不了，要不就不好写

# print(np.dot(a,c))
# [14]

# 左（主），右（从）
# 左（行），右（列）
# 通过这几个例子发现，高维数组（三维及以上），的运算方式，是有规律可循的，能用手敲出来。
# 下一步，整理例子，找规律

# np.dot实现大致步骤，分为五步
# 第一步，检查dot两边形状，能否，进行dot运算
# 第二步，根据两个数组形状生成 结果数组形状，然后根据结果形状，生成一个空白数组
# 第三步，把两个矩阵里 行 列，按照运算顺序分别取出来，放到一个一维的数组里，然后按顺序运算
# 第四步，将运算结果放入空白数组
# 第五步，返回结果
