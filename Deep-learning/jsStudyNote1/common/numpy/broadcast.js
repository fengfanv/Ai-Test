const Main = require('./main.js');
var shape = Main.shape;

const Common = require('./common.js');
var printArr = Common.printArr;

/*

实现numpy.broadcast方法

关于numpy.broadcast方法的运行基本操作，请看“broadcast.py”细心看，一看你就能明白

第一步，检查两个数组，能否使用广播机制

第二步，如果两个数组，可以使用广播机制，则进行广播处理
*/

function broadcast(arr1, arr2) {

    //第一步、检查两个数组是否支持广播机制
    let arr1Shape = shape(arr1);
    let arr2Shape = shape(arr2)

    let arr1ShapeReverse = arr1Shape.reverse();
    let arr2ShapeReverse = arr2Shape.reverse();

    for(let i=0;i<arr1ShapeReverse.length;i++){
        let arr1Item = arr1ShapeReverse[i] || 1;
        let arr2Item = arr2ShapeReverse[i] || 1;

        if(arr1Item != arr2Item){
            if(arr1Item != 1 && arr2Item != 1){
                throw new Error('broadcast:error arr1 与 arr2 无法使用广播机制！');
            }
        }
    }


    //第二步、处理两个数组

    //主要分为两个小方法
    //第一个小方法，当形状数组里某个维度的数不够时，补1的方法

    //第二个小方法，当形状数组里某个维的数是1时，变成对应的维度的小方法（这里需要注意一下，当两个数组里相关维度都是1时，不用调用此方法，只有当一个数组里是1，另一个数组里不是1时才调用）
    //下面是第二个小方法，运行时的一些操作
    /*
    如有，两个数组 a1 和 b1 
    它们的形状分别是 a1.shape=[4,3]，b1.shape=[1,3]
    这里我们发现 b1.shape的下标0处（b1的0维）是1，而a1.shape的下标0处是4，所以b1.shape下标0处，需要根据a1.shape下标0处，去变化
    a1.shape下标0处是4，所以b1.shape下标0处，需要变化成4
    --
    首先准备好需要被变形的数组b1。（变形方法参数1）
    然后告诉“变形方法”这个b1数组形状下标里第几处需要变化（或b1数组里第几维需要变化）。（变形方法参数2）这里是b1.shape下标0处（b1数组的第0维）
    再然后告诉“变形方法”会发生变化的地方，需要变成多少。（变形方法参数3）这里b1.shape下标0处需要变成 4 才能对应a1.shape下标第0处
    --
    再再然后 在变形方法里整个可以深度遍历 数组子元素 的循环方法
    循环数组子元素，一个一个的循环，当循环到数组里需要根据上面变形方法参数2和参数3来变化维度的地方的时候，根据参数2和参数3循环复制处理相关数据
    循环复制处理好数据后，把 这个数据 和 这个数据将要存放在b1数组的哪个位置下的坐标，一起临时放在一个对象里
    然后就是等待数组里所有需要被变形的地方，都复制处理好后，根据坐标，将循环复制好的数据，重新放入b1数组
    就这样，这个第二个小方法就结束了
    */


}



/*实验*/
let a1 = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
]
let b1 = [1, 2, 3]
// broadcast(a1,b1) //啥的都没打印，所以是正常的

let a2 = [
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ],
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ],
    [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ]
]
let b2 = [
    [1, 2],
    [3, 4],
    [5, 6],
    [7, 8]
]
// broadcast(a2,b2) //啥的都没打印，所以是正常的

let a3 = [
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]
]
let b3 = [
    [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ],
    [
        [10, 11, 12],
        [13, 14, 15],
        [16, 17, 18]
    ]
]
// broadcast(a3,b3) //抛错了，所以是正常的

let a4 = [
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
    ]
]
let b4 = [
    [
        [1, 2, 3, 4, 5, 6],
    ],
    [
        [7, 8, 9, 10, 11, 12],
    ],
    [
        [13, 14, 15, 16, 17, 18],
    ]
]
// broadcast(a4,b4) //啥的都没打印，所以是正常的

let a5 = [
    [0],
    [1],
    [2]
]
let b5 = [0,1,2]
// broadcast(a5,b5) //啥的都没打印，所以是正常的

let a6 = [0,0,0]
let b6 = [1]
// broadcast(a6,b6) //啥的都没打印，所以是正常的