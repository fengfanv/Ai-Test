# 基础索引案例

import numpy as np

a = np.arange(4*3*2).reshape(4,3,2)
print(a)
# [[[ 0  1]
#   [ 2  3]
#   [ 4  5]]

#  [[ 6  7]
#   [ 8  9]
#   [10 11]]

#  [[12 13]
#   [14 15]
#   [16 17]]

#  [[18 19]
#   [20 21]
#   [22 23]]]

'''
a[1]

1、补全索引；被索引数组是3维数组，这里被索引数组的第1个维度有索引参数，需要为第2,3个维度补充 :/::/slice(None)
a.shape  [4,3,2]
index    [1,:,:]
result   []

2、预测索引结果形状；被索引数组是3维数组，所以索引在不使用 np.newaxis/None 的情况下，索引结果最多也是一个3维数组
a.shape  [4,3,2]
index    [1,:,:]
result   []

被索引数组从左数第1个维度的索引参数是 整数1，不是切片，所以索引结果形状第1个维度，去除
a.shape  [4,3,2]
index    [1,:,:]
result   [-,]

被索引数组从左数第2,3个维度的索引参数是 :/::/slice(None)，所以索引结果形状第2,3维度，忽略保持不变
a.shape  [4,3,2]
index    [1,:,:]
result   [-,3,2]

结果形状 [3,2]

--------------------

a[:,1]

1、补全索引；被索引数组是3维数组，这里被索引数组的第1,2个维度有索引参数，需要为第3个维度补充 :/::/slice(None)
a.shape  [4,3,2]
index    [:,1,:]
result   []

2、预测索引结果形状
a.shape  [4,3,2]
index    [:,1,:]
result   []

被索引数组从左数第1个维度的索引参数是 :/::/slice(None) ，所以索引结果形状第1个维度，忽略保持不变
a.shape  [4,3,2]
index    [:,1,:]
result   [4]
被索引数组从左数第2个维度的索引参数是 整数1，所以索引结果形状第2个维度，去除
a.shape  [4,3,2]
index    [:,1,:]
result   [4,-]
被索引数组从左数第3个维度的索引参数是 :/::/slice(None) ，所以索引结果形状第3个维度，忽略保持不变
a.shape  [4,3,2]
index    [:,1,:]
result   [4,-,2]

结果形状 [4,2]

--------------------

a[...,1]

1、补全索引；被索引数组是3维数组，索引里有 ... ,被索引数组最后一维有索引参数，根据 ... 与 最后一维有参数 来判断，应将 ... 去除，然后为被索引数组第1,2个维度补充 :/::/slice(None)
a.shape  [4,3,2]
index    [:,:,1]
result   []

2、预测索引结果形状
a.shape  [4,3,2]
index    [:,:,1]
result   []

被索引数组从左数第1,2个维度的索引参数是 :/::/slice(None) ，所以索引结果形状第1,2个维度，忽略保持不变
a.shape  [4,3,2]
index    [:,:,1]
result   [4,3]

被索引数组从左数第3个维度的索引参数是 整数1，所以索引结果形状第3个维度，去除
a.shape  [4,3,2]
index    [:,:,1]
result   [4,3,-]

结果形状 [4,3]

--------------------

a[1:,:,1]

1、补全索引；根据被索引数组第一个维度的信息，为切片补充参数
a.shape  [4,3,2]
index    [1:4:1,:,1]
result   []

2、预测索引结果形状
a.shape  [4,3,2]
index    [1:4:1,:,1]
result   []

被索引数组从左数第1个维度的索引参数是 切片slice(1,4,1)，所以索引结果形状第1个维度，的结果是3
a.shape  [4,3,2]
index    [1:4:1,:,1]
result   [3]

被索引数组从左数第2个维度的索引参数是 :/::/slice(None) ，所以索引结果形状第2个维度，忽略保持不变
a.shape  [4,3,2]
index    [1:4:1,:,1]
result   [3,3]

被索引数组从左数第3个维度的索引参数是 整数1，所以索引结果形状第3个维度，去除
a.shape  [4,3,2]
index    [1:4:1,:,1]
result   [3,3,-]

结果形状 [3,3]

--------------------

a[1:,:1,1]

1、补全索引；根据被索引数组第1,2个维度的信息，为切片补充参数
a.shape  [4,3,2]
index    [1:4:1,0:1:1,1]
result   []

2、预测索引结果形状
a.shape  [4,3,2]
index    [1:4:1,0:1:1,1]
result   []

被索引数组从左数第1个维度的索引参数是 切片slice(1,4,1)，所以索引结果形状第1个维度，的结果是3
a.shape  [4,3,2]
index    [1:4:1,0:1:1,1]
result   [3]

被索引数组从左数第2个维度的索引参数是 切片slice(0,1,1)，所以索引结果形状第2个维度，的结果是1
a.shape  [4,3,2]
index    [1:4:1,0:1:1,1]
result   [3,1]

被索引数组从左数第3个维度的索引参数是 整数1，所以索引结果形状第3个维度，去除
a.shape  [4,3,2]
index    [1:4:1,0:1:1,1]
result   [3,1,-]

结果形状 [3,1]
'''



a=np.arange(2*3*4).reshape(2,3,4)
print(a)
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]

#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]]

'''
关于索引元祖里的 None/np.newaxis
官方文档：选择元组中的每个np.newaxis对象 用于将结果选择的维度扩展一个单位长度维度。添加的维度是np.newaxis对象在选择元祖中的位置。np.newaxis是 None 的别名，可以用None代替它，来获取相同的结果。 
个人理解：索引元祖里的None在索引时，是 不对应 被索引数组里的某个维度(或被索引数组形状数组里某个位置)的，它的作用仅是 根据它在索引元祖里相关位置 ，然后在索引结果里对应位置增加一个维度。它不会影响索引结果的数据的变化，只会影响索引结果的形状的变化。
---

a[1,None,1:3]

1、补全索引；切片参数补全；为被索引数组里没有索引参数的维度，补 :/::/slice(None)
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  []
索引元祖里第1位 整数1 对应 被索引数组里的第1个维度(形状数组里第1位)，2
索引元祖里第2位 None 不对应 被索引数组里的维度；
索引元祖里第3位 切片slice(1,3,1) 对应 被索引数组里的第2个维度(形状数组里第2位)，3
索引元祖里第4位 :/::/slice(None) 对应 被索引数组里的第3个维度(形状数组里第3位)，4

2、预测索引结果形状
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  []

索引元祖从左数第1位是，整数1，所以索引结果形状第1位，去除（对应被索引数组第1个维度）
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  [-,]

索引元祖从左数第2位是，None，所以索引结果形状第2位，增加一个维度（不对应被索引数组里的维度）
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  [-,1]

索引元祖从左数第3位是，切片slice(1,3,1)，所以索引结果形状第3位，的结果是2（对应被索引数组第2个维度）
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  [-,1,   2]

索引元祖从左数第4位是，:/::/slice(None) ，所以索引结果形状第4位，与被索引数组对应维度的尺寸，忽略保持不变（对应被索引数组第3个维度）
       a[1,None,1:3:1,:]
a.shape [2,     3,    4]
result  [-,1,   2,    4]

结果形状 [1,2,4]


---------------------

获取基本索引结果的数据

a里所有数据的坐标和数据值
[0, 0, 0] 0
[0, 0, 1] 1
[0, 0, 2] 2
[0, 0, 3] 3
[0, 1, 0] 4
[0, 1, 1] 5
[0, 1, 2] 6
[0, 1, 3] 7
[0, 2, 0] 8
[0, 2, 1] 9
[0, 2, 2] 10
[0, 2, 3] 11
[1, 0, 0] 12
[1, 0, 1] 13
[1, 0, 2] 14
[1, 0, 3] 15
[1, 1, 0] 16
[1, 1, 1] 17
[1, 1, 2] 18
[1, 1, 3] 19
[1, 2, 0] 20
[1, 2, 1] 21
[1, 2, 2] 22
[1, 2, 3] 23


基本索引获取 a[1,None,1:3:1,:] 数据
这里索引元祖里有None，在索引获取数据时，不需要None，所以把None从索引元祖里临时删除
a[1,1:3:1,:]

在索引获取数据时，使用js里printArr方法遍历数据，以获取符合索引的数据

遍历第1条数据
索引元祖与数据坐标进行比较
[1,1:3:1,:]
[0,0    ,0] 0
索引元祖第1位是 整数1 所以复合条件的坐标是1，坐标第1位是0，不符合
索引元祖第2位是 切片slice(1,3,1) 所以复合条件的坐标是1,2，坐标第2位是0，不符合（切片这里把符合条件的坐标全都列出来，然后用indexOf进行匹配）
索引元祖第3位是 :/::/slice(None) 意思是，忽略保持不变，没有条件，都行，所以复合条件的坐标是0,1,2,3，坐标第3位是0，符合
第1条数据，有2条不符合，所以不符合

遍历第2条数据
[1,1:3:1,:]
[0,0    ,1] 1
索引元祖第1位，复合条件的坐标是1，坐标第1位是0，不符合
索引元祖第2位，复合条件的坐标是1,2，坐标第2位是0，不符合
索引元祖第3位，复合条件的坐标是0,1,2,3，坐标第3位是1，符合
第2条数据，有2条不符合，所以不符合

遍历第3条数据
[1,1:3:1,:]
[0,0    ,2] 2
索引元祖第1位，复合条件的坐标是1，坐标第1位是0，不符合
索引元祖第2位，复合条件的坐标是1,2，坐标第2位是0，不符合
索引元祖第3位，复合条件的坐标是0,1,2,3，坐标第3位是2，符合
第3条数据，有2条不符合，所以不符合

...等等

遍历第17条数据
[1,1:3:1,:]
[1,1    ,0] 16
索引元祖第1位，复合条件的坐标是1，坐标第1位是1，符合
索引元祖第2位，复合条件的坐标是1,2，坐标第2位是1，符合
索引元祖第3位，复合条件的坐标是0,1,2,3，坐标第3位是0，符合
第17条数据，符合

...等等

遍历第24条数据
[1,1:3:1,:]
[1,2    ,3] 23
索引元祖第1位，复合条件的坐标是1，坐标第1位是1，符合
索引元祖第2位，复合条件的坐标是1,2，坐标第2位是2，符合
索引元祖第3位，复合条件的坐标是0,1,2,3，坐标第3位是3，符合
第24条数据，符合

'''

# 注意：以上情况没有考虑 切片slice(i,j,k) k是负值的情况

'''
第一种方法、当 切片slice(i,j,k) k是负值 时，使用如下方法解决 k 是负值的情况：
第一步，先使用上面的方法，正常顺序去遍历，把符合条件的数据都取出来（不考虑数据的顺序是否正确）；（先索引获取数据）
第二步，数据都取出来后，根据取出来的数据的原始坐标，对 数据相关维度 索引参数 切片k是负值的维度 进行掉个翻转（再翻转(再调整数据顺序)）

如：





第二种方法、当 切片slice(i,j,k) k是负值 时，使用如下方法解决 k 是负值的情况：
第一步，在索引遍历数据前，根据索引元祖里的切片，对有切片k是负值的维度，进行掉个翻转。（先翻转（先调整数据顺序））
第二步，数据某个维度里顺序根据切片k翻转后，在根据上上面的printArr进行遍历索引数据。（再索引获取数据）

如：



'''








