<!DOCTYPE html>
<!-- saved from url=(0054)https://numpy.org/doc/stable/user/basics.indexing.html -->
<html lang="en" data-theme="light" data-mode="light">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Indexing on ndarrays — NumPy v1.25 Manual</title>


  <!-- Loaded before other Sphinx assets -->
  <link href="./Indexing on ndarrays — NumPy v1.25 Manual_files/theme.css" rel="stylesheet">
  <link href="./Indexing on ndarrays — NumPy v1.25 Manual_files/bootstrap.css" rel="stylesheet">
  <link href="./Indexing on ndarrays — NumPy v1.25 Manual_files/pydata-sphinx-theme.css" rel="stylesheet">


  <link href="./Indexing on ndarrays — NumPy v1.25 Manual_files/all.min.css" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin=""
    href="https://numpy.org/doc/stable/_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin=""
    href="https://numpy.org/doc/stable/_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin=""
    href="https://numpy.org/doc/stable/_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

  <link rel="stylesheet" type="text/css" href="./Indexing on ndarrays — NumPy v1.25 Manual_files/pygments.css">
  <link rel="stylesheet" type="text/css" href="./Indexing on ndarrays — NumPy v1.25 Manual_files/graphviz.css">
  <link rel="stylesheet" type="text/css" href="./Indexing on ndarrays — NumPy v1.25 Manual_files/plot_directive.css">
  <link rel="stylesheet" type="text/css"
    href="./Indexing on ndarrays — NumPy v1.25 Manual_files/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css">
  <link rel="stylesheet" type="text/css" href="./Indexing on ndarrays — NumPy v1.25 Manual_files/numpy.css">


  <style type="text/css">
    .admonition>.admonition-title:after,
    div.admonition>.admonition-title:after {
      opacity: 0;
      display: none;
    }


    .MathJax_Preview {
      color: #888
    }

    #MathJax_Message {
      position: fixed;
      left: 1em;
      bottom: 1.5em;
      background-color: #E6E6E6;
      border: 1px solid #959595;
      margin: 0px;
      padding: 2px 8px;
      z-index: 102;
      color: black;
      font-size: 80%;
      width: auto;
      white-space: nowrap
    }

    #MathJax_MSIE_Frame {
      position: absolute;
      top: 0;
      left: 0;
      width: 0px;
      z-index: 101;
      border: 0px;
      margin: 0px;
      padding: 0px
    }

    .MathJax_Error {
      color: #CC0000;
      font-style: italic
    }
  </style>
  <style type="text/css">
    [mt_node=trans_loading]::after {
      content: '';
      vertical-align: middle !important;
      width: 1em !important;
      height: 1em !important;
      display: inline-block !important;
      margin: 0 4px !important;
      border: 2px rgba(0, 0, 0, 0.25) solid !important;
      border-top: 2px rgba(0, 0, 0, 1) solid !important;
      border-radius: 50% !important;
      padding: 0 !important;
      -webkit-animation: immersive-translate-loading-animation 0.6s infinite linear !important;
      animation: immersive-translate-loading-animation 0.6s infinite linear !important;
    }

    @keyframes immersive-translate-loading-animation {
      from {
        transform: rotate(0deg, 0deg, 0deg);
      }

      to {
        transform: rotate(359deg, 0deg, 0deg);
      }
    }
  </style>
  <style type="text/css">


  </style>
  <style type="text/css">
    .MathJax_Preview .MJXf-math {
      color: inherit !important
    }
  </style>
  <style type="text/css">
    .MJX_Assistive_MathML {
      position: absolute !important;
      top: 0;
      left: 0;
      clip: rect(1px, 1px, 1px, 1px);
      padding: 1px 0 0 0 !important;
      border: 0 !important;
      height: 1px !important;
      width: 1px !important;
      overflow: hidden !important;
      display: block !important;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .MJX_Assistive_MathML.MJX_Assistive_MathML_Block {
      width: 100% !important
    }
  </style>
  <style type="text/css">
    .MathJax_Hover_Frame {
      border-radius: .25em;
      -webkit-border-radius: .25em;
      -moz-border-radius: .25em;
      -khtml-border-radius: .25em;
      box-shadow: 0px 0px 15px #83A;
      -webkit-box-shadow: 0px 0px 15px #83A;
      -moz-box-shadow: 0px 0px 15px #83A;
      -khtml-box-shadow: 0px 0px 15px #83A;
      border: 1px solid #A6D ! important;
      display: inline-block;
      position: absolute
    }

    .MathJax_Menu_Button .MathJax_Hover_Arrow {
      position: absolute;
      cursor: pointer;
      display: inline-block;
      border: 2px solid #AAA;
      border-radius: 4px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      -khtml-border-radius: 4px;
      font-family: 'Courier New', Courier;
      font-size: 9px;
      color: #F0F0F0
    }

    .MathJax_Menu_Button .MathJax_Hover_Arrow span {
      display: block;
      background-color: #AAA;
      border: 1px solid;
      border-radius: 3px;
      line-height: 0;
      padding: 4px
    }

    .MathJax_Hover_Arrow:hover {
      color: white !important;
      border: 2px solid #CCC !important
    }

    .MathJax_Hover_Arrow:hover span {
      background-color: #CCC !important
    }
  </style>
  <style type="text/css">
    .MathJax_SVG_Display {
      text-align: center;
      margin: 1em 0em;
      position: relative;
      display: block !important;
      text-indent: 0;
      max-width: none;
      max-height: none;
      min-width: 0;
      min-height: 0;
      width: 100%
    }

    .MathJax_SVG .MJX-monospace {
      font-family: monospace
    }

    .MathJax_SVG .MJX-sans-serif {
      font-family: sans-serif
    }

    #MathJax_SVG_Tooltip {
      background-color: InfoBackground;
      color: InfoText;
      border: 1px solid black;
      box-shadow: 2px 2px 5px #AAAAAA;
      -webkit-box-shadow: 2px 2px 5px #AAAAAA;
      -moz-box-shadow: 2px 2px 5px #AAAAAA;
      -khtml-box-shadow: 2px 2px 5px #AAAAAA;
      padding: 3px 4px;
      z-index: 401;
      position: absolute;
      left: 0;
      top: 0;
      width: auto;
      height: auto;
      display: none
    }

    .MathJax_SVG {
      display: inline;
      font-style: normal;
      font-weight: normal;
      line-height: normal;
      font-size: 100%;
      font-size-adjust: none;
      text-indent: 0;
      text-align: left;
      text-transform: none;
      letter-spacing: normal;
      word-spacing: normal;
      word-wrap: normal;
      white-space: nowrap;
      float: none;
      direction: ltr;
      max-width: none;
      max-height: none;
      min-width: 0;
      min-height: 0;
      border: 0;
      padding: 0;
      margin: 0
    }

    .MathJax_SVG * {
      transition: none;
      -webkit-transition: none;
      -moz-transition: none;
      -ms-transition: none;
      -o-transition: none
    }

    .mjx-svg-href {
      fill: blue;
      stroke: blue
    }

    .MathJax_SVG_Processing {
      visibility: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
      overflow: hidden;
      display: block !important
    }

    .MathJax_SVG_Processed {
      display: none !important
    }

    .MathJax_SVG_ExBox {
      display: block !important;
      overflow: hidden;
      width: 1px;
      height: 60ex;
      min-height: 0;
      max-height: none;
      padding: 0;
      border: 0;
      margin: 0
    }

    .MathJax_SVG_LineBox {
      display: table !important
    }

    .MathJax_SVG_LineBox span {
      display: table-cell !important;
      width: 10000em !important;
      min-width: 0;
      max-width: none;
      padding: 0;
      border: 0;
      margin: 0
    }

    .MathJax_SVG .noError {
      /* vertical-align: ; */
      font-size: 90%;
      text-align: left;
      color: black;
      padding: 1px 3px;
      border: 1px solid
    }
  </style>
  <style type="text/css">
    .MJXp-script {
      font-size: .8em
    }

    .MJXp-right {
      -webkit-transform-origin: right;
      -moz-transform-origin: right;
      -ms-transform-origin: right;
      -o-transform-origin: right;
      transform-origin: right
    }

    .MJXp-bold {
      font-weight: bold
    }

    .MJXp-italic {
      font-style: italic
    }

    .MJXp-scr {
      font-family: MathJax_Script, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-frak {
      font-family: MathJax_Fraktur, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-sf {
      font-family: MathJax_SansSerif, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-cal {
      font-family: MathJax_Caligraphic, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-mono {
      font-family: MathJax_Typewriter, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-largeop {
      font-size: 150%
    }

    .MJXp-largeop.MJXp-int {
      vertical-align: -.2em
    }

    .MJXp-math {
      display: inline-block;
      line-height: 1.2;
      text-indent: 0;
      font-family: 'Times New Roman', Times, STIXGeneral, serif;
      white-space: nowrap;
      border-collapse: collapse
    }

    .MJXp-display {
      display: block;
      text-align: center;
      margin: 1em 0
    }

    .MJXp-math span {
      display: inline-block
    }

    .MJXp-box {
      display: block !important;
      text-align: center
    }

    .MJXp-box:after {
      content: " "
    }

    .MJXp-rule {
      display: block !important;
      margin-top: .1em
    }

    .MJXp-char {
      display: block !important
    }

    .MJXp-mo {
      margin: 0 .15em
    }

    .MJXp-mfrac {
      margin: 0 .125em;
      vertical-align: .25em
    }

    .MJXp-denom {
      display: inline-table !important;
      width: 100%
    }

    .MJXp-denom>* {
      display: table-row !important
    }

    .MJXp-surd {
      vertical-align: top
    }

    .MJXp-surd>* {
      display: block !important
    }

    .MJXp-script-box>* {
      display: table !important;
      height: 50%
    }

    .MJXp-script-box>*>* {
      display: table-cell !important;
      vertical-align: top
    }

    .MJXp-script-box>*:last-child>* {
      vertical-align: bottom
    }

    .MJXp-script-box>*>*>* {
      display: block !important
    }

    .MJXp-mphantom {
      visibility: hidden
    }

    .MJXp-munderover {
      display: inline-table !important
    }

    .MJXp-over {
      display: inline-block !important;
      text-align: center
    }

    .MJXp-over>* {
      display: block !important
    }

    .MJXp-munderover>* {
      display: table-row !important
    }

    .MJXp-mtable {
      vertical-align: .25em;
      margin: 0 .125em
    }

    .MJXp-mtable>* {
      display: inline-table !important;
      vertical-align: middle
    }

    .MJXp-mtr {
      display: table-row !important
    }

    .MJXp-mtd {
      display: table-cell !important;
      text-align: center;
      padding: .5em 0 0 .5em
    }

    .MJXp-mtr>.MJXp-mtd:first-child {
      padding-left: 0
    }

    .MJXp-mtr:first-child>.MJXp-mtd {
      padding-top: 0
    }

    .MJXp-mlabeledtr {
      display: table-row !important
    }

    .MJXp-mlabeledtr>.MJXp-mtd:first-child {
      padding-left: 0
    }

    .MJXp-mlabeledtr:first-child>.MJXp-mtd {
      padding-top: 0
    }

    .MJXp-merror {
      background-color: #FFFF88;
      color: #CC0000;
      border: 1px solid #CC0000;
      padding: 1px 3px;
      font-style: normal;
      font-size: 90%
    }

    .MJXp-scale0 {
      -webkit-transform: scaleX(.0);
      -moz-transform: scaleX(.0);
      -ms-transform: scaleX(.0);
      -o-transform: scaleX(.0);
      transform: scaleX(.0)
    }

    .MJXp-scale1 {
      -webkit-transform: scaleX(.1);
      -moz-transform: scaleX(.1);
      -ms-transform: scaleX(.1);
      -o-transform: scaleX(.1);
      transform: scaleX(.1)
    }

    .MJXp-scale2 {
      -webkit-transform: scaleX(.2);
      -moz-transform: scaleX(.2);
      -ms-transform: scaleX(.2);
      -o-transform: scaleX(.2);
      transform: scaleX(.2)
    }

    .MJXp-scale3 {
      -webkit-transform: scaleX(.3);
      -moz-transform: scaleX(.3);
      -ms-transform: scaleX(.3);
      -o-transform: scaleX(.3);
      transform: scaleX(.3)
    }

    .MJXp-scale4 {
      -webkit-transform: scaleX(.4);
      -moz-transform: scaleX(.4);
      -ms-transform: scaleX(.4);
      -o-transform: scaleX(.4);
      transform: scaleX(.4)
    }

    .MJXp-scale5 {
      -webkit-transform: scaleX(.5);
      -moz-transform: scaleX(.5);
      -ms-transform: scaleX(.5);
      -o-transform: scaleX(.5);
      transform: scaleX(.5)
    }

    .MJXp-scale6 {
      -webkit-transform: scaleX(.6);
      -moz-transform: scaleX(.6);
      -ms-transform: scaleX(.6);
      -o-transform: scaleX(.6);
      transform: scaleX(.6)
    }

    .MJXp-scale7 {
      -webkit-transform: scaleX(.7);
      -moz-transform: scaleX(.7);
      -ms-transform: scaleX(.7);
      -o-transform: scaleX(.7);
      transform: scaleX(.7)
    }

    .MJXp-scale8 {
      -webkit-transform: scaleX(.8);
      -moz-transform: scaleX(.8);
      -ms-transform: scaleX(.8);
      -o-transform: scaleX(.8);
      transform: scaleX(.8)
    }

    .MJXp-scale9 {
      -webkit-transform: scaleX(.9);
      -moz-transform: scaleX(.9);
      -ms-transform: scaleX(.9);
      -o-transform: scaleX(.9);
      transform: scaleX(.9)
    }

    .MathJax_PHTML .noError {
      /* vertical-align: ; */
      font-size: 90%;
      text-align: left;
      color: black;
      padding: 1px 3px;
      border: 1px solid
    }
  </style>
</head>


<body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%"
  data-default-mode="light" mt_node="origin">
  <div
    style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"
    mt_node="origin">
    <div id="MathJax_SVG_Hidden" mt_node="origin"></div><svg mt_node="origin">
      <defs id="MathJax_SVG_glyphs">
        <path stroke-width="1" id="MJMATHI-6E"
          d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z">
        </path>
        <path stroke-width="1" id="MJMATHI-69"
          d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z">
        </path>
        <path stroke-width="1" id="MJMAIN-30"
          d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z">
        </path>
        <path stroke-width="1" id="MJMAIN-2264"
          d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z">
        </path>
        <path stroke-width="1" id="MJMAIN-3C"
          d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z">
        </path>
        <path stroke-width="1" id="MJMATHI-64"
          d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z">
        </path>
        <path stroke-width="1" id="MJMAIN-2B"
          d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z">
        </path>
        <path stroke-width="1" id="MJMATHI-6B"
          d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z">
        </path>
        <path stroke-width="1" id="MJMAIN-2260"
          d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z">
        </path>
        <path stroke-width="1" id="MJMATHI-6D"
          d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z">
        </path>
        <path stroke-width="1" id="MJMAIN-3D"
          d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z">
        </path>
        <path stroke-width="1" id="MJMATHI-71"
          d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z">
        </path>
        <path stroke-width="1" id="MJMAIN-28"
          d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z">
        </path>
        <path stroke-width="1" id="MJMATHI-72"
          d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z">
        </path>
        <path stroke-width="1" id="MJMAIN-29"
          d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z">
        </path>
      </defs>
    </svg>
  </div>
  <div id="MathJax_Message" style="display: none;" mt_node="origin_leaf"></div>
  <div id="MathJax_Message" style="display: none; margin: 0px 5px;" mt_node="trans"></div>



  <a class="skip-link" href="https://numpy.org/doc/stable/user/basics.indexing.html#main-content"
    mt_node="origin_leaf">Skip to main content</a><a class="skip-link"
    href="https://numpy.org/doc/stable/user/basics.indexing.html#main-content" mt_node="trans">跳到主要内容</a>

  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary" mt_node="origin">
  <label class="overlay overlay-primary" for="__primary" mt_node="origin"></label>

  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary" mt_node="origin">
  <label class="overlay overlay-secondary" for="__secondary" mt_node="origin"></label>

  <div class="search-button__wrapper" mt_node="origin">
    <div class="search-button__overlay" mt_node="origin_leaf"></div>
    <div class="search-button__overlay" mt_node="trans" style="margin: 0px 5px;"></div>
    <div class="search-button__search-container" mt_node="origin">
      <form class="bd-search d-flex align-items-center" action="https://numpy.org/doc/stable/search.html" method="get"
        mt_node="origin">
        <i class="fa-solid fa-magnifying-glass" mt_node="origin"></i>
        <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..."
          aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
          mt_node="origin">
        <span class="search-button__kbd-shortcut" mt_node="origin"><kbd class="kbd-shortcut__modifier"
            mt_node="origin_leaf">Ctrl</kbd><kbd class="kbd-shortcut__modifier"
            mt_node="trans">Ctrl</kbd><!--volctrans extension anchor for patchId=20-->+<font mt_node="trans"
            style="vertical-align: inherit; margin: 0px 5px;">+</font><kbd mt_node="origin_leaf">K</kbd><kbd
            mt_node="trans">K</kbd></span>
      </form>
    </div>
  </div>

  <nav class="bd-header navbar navbar-expand-lg bd-navbar" mt_node="origin">
    <div class="bd-header__inner bd-page-width" mt_node="origin">

      <div class="navbar-header-items__start" mt_node="origin">

        <div class="navbar-item" mt_node="origin">


          <a class="navbar-brand logo" href="https://numpy.org/doc/stable/index.html" mt_node="origin">


            <img src="./Indexing on ndarrays — NumPy v1.25 Manual_files/numpylogo.svg" class="logo__image only-light"
              alt="Logo image" mt_node="origin">

            <img src="./Indexing on ndarrays — NumPy v1.25 Manual_files/numpylogo_dark.svg"
              class="logo__image only-dark" alt="Logo image" mt_node="origin">


          </a>
        </div>

      </div>

    </div>

  </nav>

  <div class="bd-container" mt_node="origin">
    <div class="bd-container__inner bd-page-width" mt_node="origin">


      <main id="main-content" class="bd-main" mt_node="origin">

        <div class="bd-content" mt_node="origin">
          <div class="bd-article-container" mt_node="origin">

            <div id="searchbox" mt_node="origin"></div>
            <article class="bd-article" role="main" mt_node="origin">

              <section id="indexing-on-ndarrays" mt_node="origin">
                <span id="basics-indexing" mt_node="origin_leaf"></span><span id="basics-indexing" mt_node="trans"
                  style="margin: 0px 5px;"></span>
                <h1 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=264-->Indexing on <a
                    class="reference internal"
                    href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                    title="numpy.ndarray" mt_node="origin_leaf"><code
                      class="xref py py-class docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">ndarrays</span></code></a><a class="headerlink"
                    href="https://numpy.org/doc/stable/user/basics.indexing.html#indexing-on-ndarrays"
                    title="Permalink to this heading" mt_node="origin_leaf">#</a></h1>
                <h1 mt_node="trans"><!--volctrans extension anchor for patchId=264-->索引在<a class="reference internal"
                    href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                    title="numpy.ndarray" mt_node="trans"><code class="xref py py-class docutils literal notranslate"
                      mt_node="trans"><span class="pre">ndarrays</span></code></a><a class="headerlink"
                    href="https://numpy.org/doc/stable/user/basics.indexing.html#indexing-on-ndarrays"
                    title="Permalink to this heading" mt_node="trans">#</a></h1>
                <div class="admonition seealso" mt_node="origin">
                  <p class="admonition-title" mt_node="origin_leaf">See also</p>
                  <p class="admonition-title" mt_node="trans">又见</p>
                  <p mt_node="origin_leaf"><a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/arrays.indexing.html#routines-indexing"
                      mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">Indexing routines</span></a>
                  </p>
                  <p mt_node="trans"><a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/arrays.indexing.html#routines-indexing"
                      mt_node="trans">索引例程</a></p>
                </div>
                <p id="index-0" mt_node="origin_leaf"><a class="reference internal"
                    href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                    title="numpy.ndarray" mt_node="origin_leaf"><code
                      class="xref py py-class docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">ndarrays</span></code></a><!--volctrans extension anchor for patchId=276-->
                  can be indexed using the standard Python
                  <code class="docutils literal notranslate"
                    mt_node="origin_leaf"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=278-->
                  syntax, where <em mt_node="origin_leaf">x</em><!--volctrans extension anchor for patchId=280--> is the
                  array and <em mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=282--> the
                  selection.
                  There are different kinds of indexing available depending on <em
                    mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=284-->:
                  basic indexing, advanced indexing and field access.
                </p>
                <p id="index-0" mt_node="trans">
                  <a class="reference internal"
                    href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                    title="numpy.ndarray" mt_node="trans">
                    <code class="xref py py-class docutils literal notranslate" mt_node="trans">
                      <span class="pre">ndarrays</span>
                    </code>
                  </a>
                  <!--volctrans extension anchor for patchId=276-->可以使用标准 Python
                  <code class="docutils literal notranslate" mt_node="trans">
                    <span class="pre">x[obj]</span>
                  </code>语法进行索引
                  <!--volctrans extension anchor for patchId=278-->，其中<em
                    mt_node="trans">x</em><!--volctrans extension anchor for patchId=280-->是数组，<em
                    mt_node="trans">obj</em><!--volctrans extension anchor for patchId=282-->是选择。
                  根据<em mt_node="trans">obj</em><!--volctrans extension anchor for patchId=284-->的不同，有不同类型的索引可以使用：
                  基本索引、高级索引和字段访问。
                </p>
                <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=286-->Most of the following examples
                  show the use of indexing when
                  referencing data in an array. The examples work just as well
                  when assigning to an array. See <a class="reference internal"
                    href="https://numpy.org/doc/stable/user/basics.indexing.html#assigning-values-to-indexed-arrays"
                    mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">Assigning values to indexed
                      arrays</span></a><!--volctrans extension anchor for patchId=289--> for
                  specific examples and explanations on how assignments work.</p>
                <p mt_node="trans">
                  <!--volctrans extension anchor for patchId=286-->以下大多数示例都展示了索引在引用数组中数据时的用法。这些示例在给数组赋值时同样有效。有关赋值如何工作的具体示例和解释，请参阅<a
                    class="reference internal"
                    href="https://numpy.org/doc/stable/user/basics.indexing.html#assigning-values-to-indexed-arrays"
                    mt_node="trans">为索引数组赋值</a>。</p>
                <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=291-->Note that in Python, <code
                    class="docutils literal notranslate"
                    mt_node="origin_leaf"><span class="pre">x[(exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN)]</span></code><!--volctrans extension anchor for patchId=293-->
                  is equivalent to
                  <code class="docutils literal notranslate"
                    mt_node="origin_leaf"><span class="pre">x[exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN]</span></code><!--volctrans extension anchor for patchId=295-->;
                  the latter is just syntactic sugar
                  for the former.
                </p>
                <p mt_node="trans"><!--volctrans extension anchor for patchId=291-->注意，在Python中，<code
                    class="docutils literal notranslate"
                    mt_node="trans"><span class="pre">x[(exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN)]</span></code><!--volctrans extension anchor for patchId=293-->等价于
                  <code class="docutils literal notranslate"
                    mt_node="trans"><span class="pre">x[exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN]</span></code><!--volctrans extension anchor for patchId=295-->；对于前者
                  后者只是前者的语法糖。
                </p>
                <section id="basic-indexing" mt_node="origin">
                  <span id="id1" mt_node="origin_leaf"></span><span id="id1" mt_node="trans"
                    style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=299-->Basic indexing<a
                      class="headerlink" href="https://numpy.org/doc/stable/user/basics.indexing.html#basic-indexing"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=299-->基本索引<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#basic-indexing"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <section id="single-element-indexing" mt_node="origin">
                    <span id="id2" mt_node="origin_leaf"></span><span id="id2" mt_node="trans"
                      style="margin: 0px 5px;"></span>
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=304-->Single element indexing<a
                        class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#single-element-indexing"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=304-->单个元素索引<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#single-element-indexing"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf">Single element indexing works
                      exactly like that for other standard Python sequences. It is 0-based,
                      and accepts negative indices for indexing from the end of the array.</p>
                    <p mt_node="trans">单个元素索引的工作原理与其它标准Python序列的工作原理完全相同。它从0开始，并接受从数组末尾开始索引的负索引。</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">8</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">It is not necessary to
                      separate each dimension’s index into its own set of square brackets.</p>
                    <p mt_node="trans">没有必要将每个维度的索引分别放到该维度它自己的方括号中。</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># now x is 2-dimensional</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">9</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">Note that if one indexes a multidimensional array with fewer indices
                      than dimensions, one gets a subdimensional array. For example:</p>
                    <p mt_node="trans">请注意，如果用维度少的索引对多维数组进行索引，则将得到该多维数组的子维度数组。例如：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=319-->That is, each index
                      specified selects the array corresponding to the
                      rest of the dimensions selected. In the above example, choosing 0
                      means that the remaining dimension of length 5 is being left unspecified,
                      and that what is returned is an array of that dimensionality and size.
                      It must be noted that the returned array is a <a class="reference internal"
                        href="https://numpy.org/doc/stable/glossary.html#term-view" mt_node="origin_leaf"><span
                          class="xref std std-term"
                          mt_node="origin_leaf">view</span></a><!--volctrans extension anchor for patchId=322-->, i.e.,
                      it is not a
                      copy of the original, but points to the same values in memory as does the
                      original array.
                      In this case, the 1-D array at the first position (0) is returned.
                      So using a single index on the returned array, results in a single
                      element being returned. That is:</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=319-->也就是说，指定的每个维度的索引都会选择该维度
                      后面维度的数组。在上面的例子中，仅选择0意味着长度为5的维度没有被指定，
                      所以返回的是所选维度后面的 维度长度是5的数组。
                      必须注意的是，返回的数组是一个<a class="reference internal"
                        href="https://numpy.org/doc/stable/glossary.html#term-view"
                        mt_node="trans">视图</a><!--volctrans extension anchor for patchId=322-->，也就是说，它不是原始数组的副本，它与原始数组一样都指向内存里同一个值。
                      所以在这种情况下，返回了第一个位置（0）的一维数组。
                      因此，在返回的数组上使用单个元素索引，会导致返回单个元素。如：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=327-->So note that <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[0,</span> <span class="pre">2]</span> <span class="pre">==</span> <span class="pre">x[0][2]</span></code><!--volctrans extension anchor for patchId=329-->
                      though the second case is more
                      inefficient as a new temporary array is created after the first index
                      that is subsequently indexed by 2.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=327-->所以请注意<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[0,</span> <span class="pre">2]</span> <span class="pre">==</span> <span class="pre">x[0][2]</span></code><!--volctrans extension anchor for patchId=329-->尽管第二种情况更好理解，但效率低下，因为在第一个索引之后创建了一个新的临时数组，然后这个新的临时数组又被2索引了。</p>
                    <div class="admonition note" mt_node="origin">
                      <p class="admonition-title" mt_node="origin_leaf">Note</p>
                      <p class="admonition-title" mt_node="trans">注</p>
                      <p mt_node="origin_leaf">NumPy uses C-order indexing. That means that the last
                        index usually represents the most rapidly changing memory location,
                        unlike Fortran or IDL, where the first index represents the most
                        rapidly changing location in memory. This difference represents a
                        great potential for confusion.</p>
                      <p mt_node="trans">
                        NumPy使用C顺序索引。这意味着最后一个索引通常是 内存里变化最快的内存位置，不像Fortran顺序或IDL顺序（第一个索引是内存里变化最快的内存位置）。这种差异很有可能引起混淆。</p>
                    </div>
                  </section>
                  <section id="slicing-and-striding" mt_node="origin">
                    <span id="id3" mt_node="origin_leaf"></span><span id="id3" mt_node="trans"
                      style="margin: 0px 5px;"></span>
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=336-->Slicing and striding<a
                        class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=336-->切片和步幅<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=339-->Basic slicing extends
                      Python’s basic concept of slicing to N
                      dimensions. Basic slicing occurs when <em
                        mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=341--> is a <a
                        class="reference external" href="https://docs.python.org/3/library/functions.html#slice"
                        title="(in Python v3.11)" mt_node="origin_leaf"><code
                          class="xref py py-class docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">slice</span></code></a><!--volctrans extension anchor for patchId=344-->
                      object
                      (constructed by <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">start:stop:step</span></code><!--volctrans extension anchor for patchId=346-->
                      notation inside of brackets), an
                      integer, or a tuple of slice objects and integers. <a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#Ellipsis" title="(in Python v3.11)"
                        mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=349-->
                      and <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=352-->
                      objects can be interspersed with these as
                      well.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=339-->基本切片将Python的基本切片概念扩展到了N维。
                      当<em mt_node="trans">obj</em><!--volctrans extension anchor for patchId=341-->是<a
                        class="reference external" href="https://docs.python.org/3/library/functions.html#slice"
                        title="(in Python v3.11)" mt_node="trans"><code
                          class="xref py py-class docutils literal notranslate"
                          mt_node="trans"><span class="pre">slice</span></code></a><!--volctrans extension anchor for patchId=344-->对象（由括号内的

                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">start:stop:step</span></code><!--volctrans extension anchor for patchId=346-->符号构造）、一个整数，或由切片对象和整数组成的元组时，会发生基本切片。<a
                        class="reference external" href="https://docs.python.org/3/library/constants.html#Ellipsis"
                        title="(in Python v3.11)" mt_node="trans"><code
                          class="xref py py-data docutils literal notranslate"
                          mt_node="trans"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=349-->
                      和<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=352-->也可以与这些对象混合使用。
                    </p>
                    <p id="index-1" mt_node="origin"><!--volctrans extension anchor for patchId=354-->The simplest case
                      of indexing with N integers returns an <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/arrays.scalars.html#arrays-scalars"
                        mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">array
                          scalar</span></a> representing the corresponding item. As in Python, all indices are
                      zero-based: for the <em mt_node="origin_leaf">i</em>-th index <span class="MathJax_SVG"
                        id="MathJax-Element-1-Frame" tabindex="0"
                        style="font-size: 100%; display: inline-block; position: relative;"
                        data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"
                        role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                          width="2.194ex" height="1.76ex" viewBox="0 -504.6 944.8 757.9" role="img" focusable="false"
                          style="vertical-align: -0.588ex;" aria-hidden="true" mt_node="origin">
                          <g stroke="currentColor" fill="currentColor" stroke-width="0"
                            transform="matrix(1 0 0 -1 0 0)">
                            <use href="#MJMATHI-6E" x="0" y="0"></use>
                            <use transform="scale(0.707)" href="#MJMATHI-69" x="849" y="-213"></use>
                          </g>
                        </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                            xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                            <msub>
                              <mi>n</mi>
                              <mi>i</mi>
                            </msub>
                          </math></span></span>
                      <script type="math/tex" id="MathJax-Element-1" mt_node="origin">n_i</script>
                      </span>, the valid range is <span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0"
                        style="font-size: 100%; display: inline-block; position: relative;"
                        data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;&amp;#x2264;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"
                        role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                          width="11.562ex" height="2.344ex" viewBox="0 -755.9 4978.2 1009.2" role="img"
                          focusable="false" style="vertical-align: -0.588ex;" aria-hidden="true" mt_node="origin">
                          <g stroke="currentColor" fill="currentColor" stroke-width="0"
                            transform="matrix(1 0 0 -1 0 0)">
                            <use href="#MJMAIN-30" x="0" y="0"></use>
                            <use href="#MJMAIN-2264" x="778" y="0"></use>
                            <g transform="translate(1834,0)">
                              <use href="#MJMATHI-6E" x="0" y="0"></use>
                              <use transform="scale(0.707)" href="#MJMATHI-69" x="849" y="-213"></use>
                            </g>
                            <use href="#MJMAIN-3C" x="3057" y="0"></use>
                            <g transform="translate(4113,0)">
                              <use href="#MJMATHI-64" x="0" y="0"></use>
                              <use transform="scale(0.707)" href="#MJMATHI-69" x="736" y="-213"></use>
                            </g>
                          </g>
                        </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                            xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                            <mn>0</mn>
                            <mo>≤</mo>
                            <msub>
                              <mi>n</mi>
                              <mi>i</mi>
                            </msub>
                            <mo>&lt;</mo>
                            <msub>
                              <mi>d</mi>
                              <mi>i</mi>
                            </msub>
                          </math></span></span>
                      <script type="math/tex" id="MathJax-Element-2" mt_node="origin">0 \le n_i < d_i</script>
                      </span>where <span class="math notranslate nohighlight" mt_node="origin"><span
                          class="MathJax_Preview" style="color: inherit; display: none;" mt_node="origin"></span><span
                          class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0"
                          style="font-size: 100%; display: inline-block; position: relative;"
                          data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"
                          role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                            width="2.009ex" height="2.344ex" viewBox="0 -755.9 864.8 1009.2" role="img"
                            focusable="false" style="vertical-align: -0.588ex;" aria-hidden="true" mt_node="origin">
                            <g stroke="currentColor" fill="currentColor" stroke-width="0"
                              transform="matrix(1 0 0 -1 0 0)">
                              <use href="#MJMATHI-64" x="0" y="0"></use>
                              <use transform="scale(0.707)" href="#MJMATHI-69" x="736" y="-213"></use>
                            </g>
                          </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                              xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                              <msub>
                                <mi>d</mi>
                                <mi>i</mi>
                              </msub>
                            </math></span></span>
                        <script type="math/tex" id="MathJax-Element-3" mt_node="origin">d_i</script>
                      </span> is the <em mt_node="origin_leaf">i</em>-th element of the shape of the array. Negative
                      indices are interpreted as counting from the end of the array (<em>i.e.</em>, if <span
                        class="math notranslate nohighlight" mt_node="origin"><span class="MathJax_Preview"
                          style="color: inherit; display: none;" mt_node="origin"></span><span class="MathJax_SVG"
                          id="MathJax-Element-4-Frame" tabindex="0"
                          style="font-size: 100%; display: inline-block; position: relative;"
                          data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"
                          role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                            width="6.455ex" height="2.344ex" viewBox="0 -755.9 2779.4 1009.2" role="img"
                            focusable="false" style="vertical-align: -0.588ex;" aria-hidden="true" mt_node="origin">
                            <g stroke="currentColor" fill="currentColor" stroke-width="0"
                              transform="matrix(1 0 0 -1 0 0)">
                              <use href="#MJMATHI-6E" x="0" y="0"></use>
                              <use transform="scale(0.707)" href="#MJMATHI-69" x="849" y="-213"></use>
                              <use href="#MJMAIN-3C" x="1222" y="0"></use>
                              <use href="#MJMAIN-30" x="2278" y="0"></use>
                            </g>
                          </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                              xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                              <msub>
                                <mi>n</mi>
                                <mi>i</mi>
                              </msub>
                              <mo>&lt;</mo>
                              <mn>0</mn>
                            </math></span></span>
                        <script type="math/tex" id="MathJax-Element-4" mt_node="origin">n_i < 0</script>
                      </span>, it means <span class="math notranslate nohighlight" mt_node="origin"><span
                          class="MathJax_Preview" style="color: inherit; display: none;" mt_node="origin"></span><span
                          class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0"
                          style="font-size: 100%; display: inline-block; position: relative;"
                          data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"
                          role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                            width="7.043ex" height="2.344ex" viewBox="0 -755.9 3032.6 1009.2" role="img"
                            focusable="false" style="vertical-align: -0.588ex;" aria-hidden="true" mt_node="origin">
                            <g stroke="currentColor" fill="currentColor" stroke-width="0"
                              transform="matrix(1 0 0 -1 0 0)">
                              <use href="#MJMATHI-6E" x="0" y="0"></use>
                              <use transform="scale(0.707)" href="#MJMATHI-69" x="849" y="-213"></use>
                              <use href="#MJMAIN-2B" x="1167" y="0"></use>
                              <g transform="translate(2167,0)">
                                <use href="#MJMATHI-64" x="0" y="0"></use>
                                <use transform="scale(0.707)" href="#MJMATHI-69" x="736" y="-213"></use>
                              </g>
                            </g>
                          </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                              xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                              <msub>
                                <mi>n</mi>
                                <mi>i</mi>
                              </msub>
                              <mo>+</mo>
                              <msub>
                                <mi>d</mi>
                                <mi>i</mi>
                              </msub>
                            </math></span></span>
                        <script type="math/tex" id="MathJax-Element-5" mt_node="origin">n_i + d_i</script>
                      </span>).
                    </p>
                    <p mt_node="origin_leaf">
                      用N个整数进行索引的最简单情况是，使用一个数组标量，来表示相应的项。与Python一样，所有索引都是从零开始的，如对于第i个索引ni，其有效范围为 0 <= ni < di
                        其中di是指 形状数组里的第i个元素。负索引被解释为从数组末尾开始计数(即，如果 ni < 0，则表示 ni + di ) </p>
                        <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=407-->All arrays generated
                          by
                          basic slicing are always <a class="reference internal"
                            href="https://numpy.org/doc/stable/glossary.html#term-view" mt_node="origin_leaf"><span
                              class="xref std std-term"
                              mt_node="origin_leaf">views</span></a><!--volctrans extension anchor for patchId=410-->
                          of the original array.</p>
                        <p mt_node="trans"><!--volctrans extension anchor for patchId=407-->所有由基本切片生成的数组都是原始数组的<a
                            class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-view"
                            mt_node="trans">视图</a>。</p>
                        <div class="admonition note" mt_node="origin">
                          <p class="admonition-title" mt_node="origin_leaf">Note</p>
                          <p class="admonition-title" mt_node="trans">注</p>
                          <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=414-->NumPy slicing
                            creates a
                            <a class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-view"
                              mt_node="origin_leaf"><span class="xref std std-term"
                                mt_node="origin_leaf">view</span></a><!--volctrans extension anchor for patchId=417-->
                            instead of a copy as in the case of
                            built-in Python sequences such as string, tuple and list.
                            Care must be taken when extracting
                            a small portion from a large array which becomes useless after the
                            extraction, because the small portion extracted contains a reference
                            to the large original array whose memory will not be released until
                            all arrays derived from it are garbage-collected. In such cases an
                            explicit <code class="docutils literal notranslate"
                              mt_node="origin_leaf"><span class="pre">copy()</span></code><!--volctrans extension anchor for patchId=419-->
                            is recommended.
                          </p>
                          <p mt_node="trans"><!--volctrans extension anchor for patchId=414-->NumPy切片创建一个<a
                              class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-view"
                              mt_node="trans">视图</a><!--volctrans extension anchor for patchId=417-->，而不是像string、tuple和list等内置Python序列那样创建副本。
                            当从一个大数组中提取一小部分时，必须小心，因为提取出来的小部分包含有对原始大数组的引用，由原始大数组所派生的所有数组被垃圾回收之前，原始大数组的内存不会被释放。
                            在这种情况下，建议使用<code class="docutils literal notranslate"
                              mt_node="trans"><span class="pre">copy()</span></code><!--volctrans extension anchor for patchId=419-->
                            来创建副本（来切断对原始大数组的引用）。
                          </p>
                        </div>
                        <p mt_node="origin_leaf">The standard rules of sequence slicing apply to basic slicing on a
                          per-dimension basis (including using a step index). Some useful
                          concepts to remember include:</p>
                        <p mt_node="trans">标准的序列切片规则适用于每个维度的基本切片（包括使用步长索引）。要记住的一些有用概念包括：</p>
                        <ul mt_node="origin">
                          <li mt_node="origin">
                            <p mt_node="origin"><!--volctrans extension anchor for patchId=424-->The basic slice syntax
                              is
                              <code class="docutils literal notranslate"
                                mt_node="origin"><span class="pre">i:j:k</span></code><!--volctrans extension anchor for patchId=426-->
                              where <em mt_node="origin_leaf">i</em><!--volctrans extension anchor for patchId=428--> is
                              the starting
                              index,
                              <em mt_node="trans">j</em><!--volctrans extension anchor for patchId=430--> is the
                              stopping
                              index, and <em mt_node="trans">k</em><!--volctrans extension anchor for patchId=432--> is
                              the step (<span class="math notranslate nohighlight" mt_node="origin"><span
                                  class="MathJax_Preview" style="color: inherit; display: none;"
                                  mt_node="origin"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame"
                                  tabindex="0" style="font-size: 100%; display: inline-block; position: relative;"
                                  data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2260;&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"
                                  role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                                    width="5.472ex" height="2.577ex" viewBox="0 -806.1 2356.1 1109.7" role="img"
                                    focusable="false" style="vertical-align: -0.705ex;" aria-hidden="true"
                                    mt_node="origin">
                                    <g stroke="currentColor" fill="currentColor" stroke-width="0"
                                      transform="matrix(1 0 0 -1 0 0)">
                                      <use href="#MJMATHI-6B" x="0" y="0"></use>
                                      <use href="#MJMAIN-2260" x="799" y="0"></use>
                                      <use href="#MJMAIN-30" x="1855" y="0"></use>
                                    </g>
                                  </svg><span class="MJX_Assistive_MathML" role="presentation" mt_node="origin"><math
                                      xmlns="http://www.w3.org/1998/Math/MathML" mt_node="origin">
                                      <mi>k</mi>
                                      <mo>≠</mo>
                                      <mn>0</mn>
                                    </math></span></span>
                                <script type="math/tex" id="MathJax-Element-6" mt_node="origin">k\neq0</script>
                              </span><!--volctrans extension anchor for patchId=440-->).
                              This selects the <em
                                mt_node="origin_leaf">m</em><!--volctrans extension anchor for patchId=442--> elements
                              (in the
                              corresponding dimension) with
                              index values <em mt_node="origin_leaf">i</em>, <em mt_node="origin_leaf">i + k</em>, …,
                              <em mt_node="origin_leaf">i + (m - 1) k</em> where
                              <span class="math notranslate nohighlight" mt_node="origin"><span class="MathJax_Preview"
                                  style="color: inherit; display: none;" mt_node="origin_leaf"></span><span
                                  class="MathJax_Preview" style="color: inherit; display: none;"
                                  mt_node="trans"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame"
                                  tabindex="0" style="font-size: 100%; display: inline-block; position: relative;"
                                  data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;&amp;#x2260;&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"
                                  role="presentation" mt_node="origin"><svg xmlns:xlink="http://www.w3.org/1999/xlink"
                                    width="16.168ex" height="2.577ex" viewBox="0 -806.1 6961.1 1109.7" role="img"
                                    focusable="false" style="vertical-align: -0.705ex;" aria-hidden="true"
                                    mt_node="origin">
                                    <g stroke="currentColor" fill="currentColor" stroke-width="0"
                                      transform="matrix(1 0 0 -1 0 0)">
                                      <use href="#MJMATHI-6D" x="0" y="0"></use>
                                      <use href="#MJMAIN-3D" x="1156" y="0"></use>
                                      <use href="#MJMATHI-71" x="2212" y="0"></use>
                                      <use href="#MJMAIN-2B" x="2895" y="0"></use>
                                      <use href="#MJMAIN-28" x="3896" y="0"></use>
                                      <use href="#MJMATHI-72" x="4285" y="0"></use>
                                      <use href="#MJMAIN-2260" x="5014" y="0"></use>
                                      <use href="#MJMAIN-30" x="6071" y="0"></use>
                                      <use href="#MJMAIN-29" x="6571" y="0"></use>
                                    </g>
                                  </svg><span class="MJX_Assistive_MathML" role="presentation"
                                    mt_node="origin_leaf"><math xmlns="http://www.w3.org/1998/Math/MathML"
                                      mt_node="origin_leaf">
                                      <mi>m</mi>
                                      <mo>=</mo>
                                      <mi>q</mi>
                                      <mo>+</mo>
                                      <mo stretchy="false">(</mo>
                                      <mi>r</mi>
                                      <mo>≠</mo>
                                      <mn>0</mn>
                                      <mo stretchy="false">)</mo>
                                    </math></span><span class="MJX_Assistive_MathML" role="presentation"
                                    mt_node="trans"><math xmlns="http://www.w3.org/1998/Math/MathML" mt_node="trans">
                                      <mi>m</mi>
                                      <mo>=</mo>
                                      <mi>q</mi>
                                      <mo>+</mo>
                                      <mo stretchy="false">(</mo>
                                      <mi>r</mi>
                                      <mo>≠</mo>
                                      <mn>0</mn>
                                      <mo stretchy="false">)</mo>
                                    </math></span></span>
                                <script type="math/tex" id="MathJax-Element-7"
                                  mt_node="origin">m = q + (r\neq0)</script>
                              </span><!--volctrans extension anchor for patchId=456--> and <em
                                mt_node="trans">q</em><!--volctrans extension anchor for patchId=458--> and <em
                                mt_node="trans">r</em><!--volctrans extension anchor for patchId=460--> are the quotient
                              and
                              remainder
                              obtained by dividing <em mt_node="origin_leaf">j - i</em> by <em
                                mt_node="trans">k</em><!--volctrans extension anchor for patchId=464-->: <em
                                mt_node="trans">j - i = q
                                k + r</em><!--volctrans extension anchor for patchId=466-->, so that
                              <em mt_node="origin_leaf">i + (m - 1) k &lt;
                                j</em><!--volctrans extension anchor for patchId=468-->.
                              For example:
                            </p>
                            <p mt_node="origin">
                              基本的切片语法是i:j:k，其中i是开始索引，j是停止索引，k是步长(k≠0)。基本切片语法所选取数据的索引值为 i, i + k，…，i + (m - 1)
                              k的m个元素(在相应维度中)，其中m = q + (r≠0)，q和r是通过将j - i除以k得到的商和余数:j - i = q k + r，因此i + (m - 1) k < j。例如： </p>
                                <div class="highlight-default notranslate" mt_node="origin">
                                  <div class="highlight" mt_node="origin">
                                    <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([1, 3, 5])</span>
</pre>
                                  </div>
                                </div>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=474-->Negative <em
                                mt_node="origin_leaf">i</em><!--volctrans extension anchor for patchId=476--> and <em
                                mt_node="origin_leaf">j</em><!--volctrans extension anchor for patchId=478--> are
                              interpreted as <em mt_node="origin_leaf">n +
                                i</em><!--volctrans extension anchor for patchId=480--> and <em mt_node="origin_leaf">n
                                +
                                j</em><!--volctrans extension anchor for patchId=482--> where
                              <em mt_node="origin_leaf">n</em><!--volctrans extension anchor for patchId=484--> is the
                              number of elements in the corresponding dimension.
                              Negative <em mt_node="origin_leaf">k</em><!--volctrans extension anchor for patchId=486-->
                              makes stepping go towards smaller indices.
                              From the above example:
                            </p>
                            <p mt_node="trans">负i和j被解释为n+i和n+j，其中n是相应维度中元素的数量。负的k使步长向较小的索引方向移动。从上面的例子中：</p>
                            <div class="highlight-default notranslate" mt_node="origin">
                              <div class="highlight" mt_node="origin">
                                <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">array([8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([7, 6, 5, 4])</span>
</pre>
                              </div>
                            </div>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=492-->Assume <em
                                mt_node="origin_leaf">n</em><!--volctrans extension anchor for patchId=494--> is the
                              number
                              of elements in the dimension being
                              sliced. Then, if <em
                                mt_node="origin_leaf">i</em><!--volctrans extension anchor for patchId=496--> is not
                              given
                              it defaults to 0 for <em mt_node="origin_leaf">k &gt;
                                0</em><!--volctrans extension anchor for patchId=498--> and
                              <em mt_node="origin_leaf">n - 1</em><!--volctrans extension anchor for patchId=500--> for
                              <em mt_node="origin_leaf">k &lt; 0</em><!--volctrans extension anchor for patchId=502--> .
                              If
                              <em mt_node="origin_leaf">j</em><!--volctrans extension anchor for patchId=504--> is not
                              given
                              it defaults to <em
                                mt_node="origin_leaf">n</em><!--volctrans extension anchor for patchId=506--> for <em
                                mt_node="origin_leaf">k &gt; 0</em><!--volctrans extension anchor for patchId=508-->
                              and <em mt_node="origin_leaf">-n-1</em><!--volctrans extension anchor for patchId=510-->
                              for
                              <em mt_node="origin_leaf">k &lt; 0</em><!--volctrans extension anchor for patchId=512--> .
                              If
                              <em mt_node="origin_leaf">k</em><!--volctrans extension anchor for patchId=514--> is not
                              given
                              it defaults to 1. Note that
                              <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">::</span></code><!--volctrans extension anchor for patchId=516-->
                              is the same as <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=518-->
                              and means select all indices along this
                              axis.
                              From the above example:
                            </p>
                            <p mt_node="trans">假设n是正在切片的维度中的元素数量。那么，如果没有给出i，则对于 k > 0 ，i 它默认为 0，对于 k < 0，i 它默认为 n -
                                1。 如果没有给出j，则对于k> 0，j 它默认为n，对于k < 0，则 j 默认为 -n - 1。 如果没有给定k，则 k 默认为1。请注意 :: 与 :
                                  相同，表示沿着这个轴选择所有索引。从上面的例子来看： </p>
                                  <div class="highlight-default notranslate" mt_node="origin">
                                    <div class="highlight" mt_node="origin">
                                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">array([5, 6, 7, 8, 9])</span>
</pre>
                                    </div>
                                  </div>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=524-->If the number of
                              objects in the selection tuple is less than
                              <em mt_node="origin_leaf">N</em><!--volctrans extension anchor for patchId=526-->, then
                              <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=528-->
                              is assumed for any subsequent dimensions.
                              For example:
                            </p>
                            <p mt_node="trans"><!--volctrans extension anchor for patchId=524-->如果选择元组中的对象数量小于
                              <em mt_node="trans">N</em><!--volctrans extension anchor for patchId=526-->，则对任何后续维度都假定为<code
                                class="docutils literal notranslate"
                                mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=528-->例如：
                            </p>
                            <div class="highlight-default notranslate" mt_node="origin">
                              <div class="highlight" mt_node="origin">
                                <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([[[4],</span>
<span class="go">        [5],</span>
<span class="go">        [6]]])</span>
</pre>
                              </div>
                            </div>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=534-->An integer, <em
                                mt_node="origin_leaf">i</em><!--volctrans extension anchor for patchId=536-->, returns
                              the
                              same values as <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">i:i+1</span></code>
                              <strong
                                mt_node="origin_leaf">except</strong><!--volctrans extension anchor for patchId=539-->
                              the dimensionality of the returned object is reduced by
                              1. In particular, a selection tuple with the <em
                                mt_node="origin_leaf">p</em><!--volctrans extension anchor for patchId=541-->-th
                              element an integer (and all other entries <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=543-->)
                              returns the
                              corresponding sub-array with dimension <em mt_node="origin_leaf">N -
                                1</em><!--volctrans extension anchor for patchId=545-->. If <em mt_node="origin_leaf">N
                                =
                                1</em><!--volctrans extension anchor for patchId=547-->
                              then the returned object is an array scalar. These objects are
                              explained in <a class="reference internal"
                                href="https://numpy.org/doc/stable/reference/arrays.scalars.html#arrays-scalars"
                                mt_node="origin_leaf"><span class="std std-ref"
                                  mt_node="origin_leaf">Scalars</span></a><!--volctrans extension anchor for patchId=550-->.
                            </p>
                            <p mt_node="trans"><!--volctrans extension anchor for patchId=534-->整数<em
                                mt_node="trans">i</em><!--volctrans extension anchor for patchId=536-->返回的值与<code
                                class="docutils literal notranslate"
                                mt_node="trans"><span class="pre">i:i+1</span></code>
                              相同，<strong
                                mt_node="trans">只是</strong><!--volctrans extension anchor for patchId=539-->返回的值维数减少了1.
                              特别是，一个具有第<em
                              mt_node="trans">p</em>个元素为整数（索引元组除了第p个是整数，所有其他索引为<code class="docutils literal notranslate"
                                mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=543-->）的选择元组 返回具有维度<em mt_node="trans">N-1</em><!--volctrans extension anchor for patchId=545-->的相应子数组。如果<em
                                mt_node="trans">N=1</em><!--volctrans extension anchor for patchId=547-->则返回的对象是数组标量。
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=553-->If the selection
                              tuple
                              has all entries <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=555-->
                              except the
                              <em mt_node="origin_leaf">p</em><!--volctrans extension anchor for patchId=557-->-th entry
                              which is a slice object <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">i:j:k</span></code><!--volctrans extension anchor for patchId=559-->,
                              then the returned array has dimension <em
                                mt_node="origin_leaf">N</em><!--volctrans extension anchor for patchId=561--> formed by
                              concatenating the sub-arrays returned by integer indexing of
                              elements <em
                                mt_node="origin_leaf">i</em><!--volctrans extension anchor for patchId=563-->,
                              <em mt_node="origin_leaf">i+k</em><!--volctrans extension anchor for patchId=565-->, …,
                              <em mt_node="origin_leaf">i + (m - 1) k &lt;
                                j</em><!--volctrans extension anchor for patchId=567-->,
                            </p>
                            <p mt_node="trans"><!--volctrans extension anchor for patchId=553-->
                              如果 选择元组 除了第p个条目是切片对象i:j:k之外，所有条目均为：，则返回的数组具有由元素i，i+k，…，i+（m-1）k＜j的整数索引返回的子数组合并形成的N维数组，
                            </p>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=570-->Basic slicing with
                              more than one non-<code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=572-->
                              entry in the slicing
                              tuple, acts like repeated application of slicing using a single
                              non-<code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=574-->
                              entry, where the non-<code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=576-->
                              entries are successively taken
                              (with all other non-<code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=578-->
                              entries replaced by <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=580-->).
                              Thus,
                              <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[ind1,</span> <span class="pre">...,</span> <span class="pre">ind2,:]</span></code><!--volctrans extension anchor for patchId=582-->
                              acts like <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[ind1][...,</span> <span class="pre">ind2,</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=584-->
                              under basic
                              slicing.
                            </p>
                            <p mt_node="trans"><!--volctrans extension anchor for patchId=570-->
                              当切片元组中具有一个以上非:条目时，基本切片的行为就像使用单个:条目，重复切片操作。其中非:条目，是连续取的（所有其他非:项被替换为:）。因此，x[ind1，…，ind2，:]的行为就像在基本切片下x[ind1][…，ind2，:]一样。
                            </p>
                            <p>
                              1、选择元组(selection tuple)是一个可以包含冒号(:)或整数或其它切片对象的元组，用于对数组进行索引。<br>
                              2、选择元组的第p个元素可以是整数或切片对象等等。<br>
                              3、如果选择元组中除了第p个元素是整数外，其他元素都是冒号(:)，则返回的数组的维度将减少1。<br>
                              4、如果选择元组的第p个元素是切片对象，则返回的数组的维度将由通过整数索引返回的子数组拼接而成。<br>
                              5、在基本切片(basic slicing)中，如果有多个非冒号(:)元素，则将其视为连续使用基本切片操作，其中每次使用一个非冒号元素，并替换其他非冒号元素为冒号(:)。
                            </p>
                            <div class="admonition warning" mt_node="origin">
                              <p class="admonition-title" mt_node="origin_leaf">Warning</p>
                              <p class="admonition-title" mt_node="trans">警告</p>
                              <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=588-->The above is
                                <strong
                                  mt_node="origin_leaf">not</strong><!--volctrans extension anchor for patchId=590-->
                                true
                                for advanced indexing.</p>
                              <p mt_node="trans">对于高级索引，上述情况并非如此。</p>
                            </div>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=593-->You may use
                              slicing to
                              set values in the array, but (unlike lists) you
                              can never grow the array. The size of the value to be set in
                              <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[obj]</span> <span class="pre">=</span> <span class="pre">value</span></code><!--volctrans extension anchor for patchId=595-->
                              must be (broadcastable to) the same shape as
                              <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=597-->.
                            </p>
                            <p mt_node="trans">
                              <!--volctrans extension anchor for patchId=593-->您可以使用切片来设置数组中的值，但（与列表不同）您
                              永远无法增长数组。要设置的值的大小
                              <code class="docutils literal notranslate"
                                mt_node="trans"><span class="pre">x[obj]</span> <span class="pre">=</span> <span class="pre">value</span></code><!--volctrans extension anchor for patchId=595-->必须是（可广播的）相同的形状
                              <code class="docutils literal notranslate"
                                mt_node="trans"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=597-->.
                            </p>
                          </li>
                          <li mt_node="origin">
                            <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=600-->A slicing tuple
                              can
                              always be constructed as <em
                                mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=602-->
                              and used in the <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=604-->
                              notation. Slice objects can be used in
                              the construction in place of the <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">[start:stop:step]</span></code><!--volctrans extension anchor for patchId=606-->
                              notation. For example, <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">x[1:10:5,</span> <span class="pre">::-1]</span></code><!--volctrans extension anchor for patchId=608-->
                              can also be implemented
                              as <code class="docutils literal notranslate"
                                mt_node="origin_leaf"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">(slice(1,</span> <span class="pre">10,</span> <span class="pre">5),</span> <span class="pre">slice(None,</span> <span class="pre">None,</span> <span class="pre">-1));</span> <span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=610-->
                              . This
                              can be useful for constructing generic code that works on arrays
                              of arbitrary dimensions. See <a class="reference internal"
                                href="https://numpy.org/doc/stable/user/basics.indexing.html#dealing-with-variable-indices"
                                mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">Dealing with
                                  variable
                                  numbers of indices within
                                  programs</span></a><!--volctrans extension anchor for patchId=613-->
                              for more information.</p>
                            <p mt_node="trans">
                              切片元组总是可以构造为obj，并在x[obj]表示法中使用。切片对象可以用来代替[start:stop:step]符号。例如，x[1:10:5，::-1]也可以通过obj=（slice（1，10，5），slice（None，None，-1））；x[obj]这样的方式实现。这对于在任意维数的数组上构建通用代码很有用。有关更多信息，请参见处理程序中的可变索引数。
                            </p>
                          </li>
                        </ul>
                  </section>
                  <section id="dimensional-indexing-tools" mt_node="origin">
                    <span id="index-2" mt_node="origin_leaf"></span><span id="index-2" mt_node="trans"
                      style="margin: 0px 5px;"></span><span id="id4" mt_node="origin_leaf"></span><span id="id4"
                      mt_node="trans" style="margin: 0px 5px;"></span>
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=618-->Dimensional indexing
                      tools<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#dimensional-indexing-tools"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=618-->维度索引工具<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#dimensional-indexing-tools"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf">There are some tools to facilitate the easy matching of array shapes with
                      expressions and in assignments.</p>
                    <p mt_node="trans">有一些工具可以方便地将数组形状与表达式和赋值进行匹配。</p>
                    <p mt_node="origin_leaf"><a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#Ellipsis" title="(in Python v3.11)"
                        mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=624-->
                      expands to the number of <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=626-->
                      objects needed for the
                      selection tuple to index all dimensions. In most cases, this means that the
                      length of the expanded selection tuple is <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x.ndim</span></code><!--volctrans extension anchor for patchId=628-->.
                      There may only be a
                      single ellipsis present.
                      From the above example:</p>
                    <p mt_node="trans"><a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#Ellipsis" title="(in Python v3.11)"
                        mt_node="trans"><code class="xref py py-data docutils literal notranslate"
                          mt_node="trans"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=624-->扩展，为选择元组索引补充所需数量的<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=626-->对象。以便 选择元组 为所有维度都建立索引。这意味着
                      扩展后的 选择元组 的长度是<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x.ndim</span></code><!--volctrans extension anchor for patchId=628-->。可能只有一个单省略号。
                      从上面的例子来看：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">      [4, 5, 6]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">This is equivalent to:</p>
                    <p mt_node="trans">这相当于：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">      [4, 5, 6]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=637-->Each <a
                        class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=640-->
                      object in the selection tuple serves to expand
                      the dimensions of the resulting selection by one unit-length
                      dimension. The added dimension is the position of the <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=643-->
                      object in the selection tuple. <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=646-->
                      is an alias for
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">None</span></code><!--volctrans extension anchor for patchId=648-->,
                      and <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">None</span></code><!--volctrans extension anchor for patchId=650-->
                      can be used in place of this with the same result.
                      From the above example:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=637-->
                      选择元组中的每个
                      <a
                        class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=640-->对象
                          用于将所得选择的空间维度扩展一个单位长度维度。添加的维度是选择元组中<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=643-->
                          对象的位置。<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=646-->是
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">None</span></code>
                        的别名，可以用
                        <!--volctrans extension anchor for patchId=648--><code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">None</span></code><!--volctrans extension anchor for patchId=650-->代替它，来获取相同的结果。从上面的示例中：
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3, 1)</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">This can be handy to combine two
                      arrays in a way that otherwise would require explicit reshaping
                      operations. For example:</p>
                    <p mt_node="trans">这可以方便地以一种 显式整形操作方式 组合两个数组，例如：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">      [1, 2, 3, 4, 5],</span>
<span class="go">      [2, 3, 4, 5, 6],</span>
<span class="go">      [3, 4, 5, 6, 7],</span>
<span class="go">      [4, 5, 6, 7, 8]])</span>
</pre>
                      </div>
                    </div>
                  </section>
                </section>
                <section id="advanced-indexing" mt_node="origin">
                  <span id="id5" mt_node="origin_leaf"></span><span id="id5" mt_node="trans"
                    style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=661-->Advanced indexing<a
                      class="headerlink" href="https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=661-->高级索引<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=664-->Advanced indexing is
                    triggered when the selection object, <em
                      mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=666-->, is a
                    non-tuple sequence object, an <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                      title="numpy.ndarray" mt_node="origin_leaf"><code
                        class="xref py py-class docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ndarray</span></code></a><!--volctrans extension anchor for patchId=669-->
                    (of data type integer or bool),
                    or a tuple with at least one sequence object or ndarray (of data type
                    integer or bool). There are two types of advanced indexing: integer
                    and Boolean.</p>
                  <p mt_node="trans">当选择对象obj是一个非元组序列对象、是一个ndarray(数据类型为整数或布尔)、或者是一个至少包含一个序列对象或ndarray(数据类型为整数或布尔)的元组时，会触发高级索引。有两种类型的高级索引：整数索引和布尔索引。（Python序列对象，列表List、元组Tuple、集合Sets、字典Dictionary等等）</p>
                  <p mt_node="trans">高级索引，是当选择对象obj是一个非元组序列对象、一个ndarray(数据类型为整数或布尔值)，或者一个至少包含一个序列对象或ndarray(数据类型为整数或布尔值)的元组时触发的。高级索引有两种类型: 整数索引和布尔索引。</p>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=671-->Advanced indexing always
                    returns a <em mt_node="origin_leaf">copy</em><!--volctrans extension anchor for patchId=673--> of
                    the data (contrast with
                    basic slicing that returns a <a class="reference internal"
                      href="https://numpy.org/doc/stable/glossary.html#term-view" mt_node="origin_leaf"><span
                        class="xref std std-term"
                        mt_node="origin_leaf">view</span></a><!--volctrans extension anchor for patchId=676-->).</p>

                  <p mt_node="trans"><!--volctrans extension anchor for patchId=671-->高级索引总是返回数据的副本(与返回视图的基本切片相反)。</p>
                  <div class="admonition warning" mt_node="origin">
                    <p class="admonition-title" mt_node="origin_leaf">Warning</p>
                    <p class="admonition-title" mt_node="trans">警告</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=680-->The definition of advanced
                      indexing means that <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[(1,</span> <span class="pre">2,</span> <span class="pre">3),]</span></code><!--volctrans extension anchor for patchId=682-->
                      is
                      fundamentally different than <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[(1,</span> <span class="pre">2,</span> <span class="pre">3)]</span></code><!--volctrans extension anchor for patchId=684-->.
                      The latter is
                      equivalent to <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code><!--volctrans extension anchor for patchId=686-->
                      which will trigger basic selection while
                      the former will trigger advanced indexing. Be sure to understand
                      why this occurs.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=680-->高级索引的定义意味着<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[(1,</span> <span class="pre">2,</span> <span class="pre">3),]</span></code><!--volctrans extension anchor for patchId=682-->是
                      根本不同于<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[(1,</span> <span class="pre">2,</span> <span class="pre">3)]</span></code><!--volctrans extension anchor for patchId=684-->。后者是
                      相当于<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code><!--volctrans extension anchor for patchId=686-->这将触发基本选择
                      前者会触发高级索引。一定要了解
                      为什么会发生这种情况。</p>
                  </div>
                  <section id="integer-array-indexing" mt_node="origin">
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=689-->Integer array indexing<a
                        class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#integer-array-indexing"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=689-->整数数组索引<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#integer-array-indexing"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=692-->Integer array indexing
                      allows selection of arbitrary items in the array
                      based on their <em
                        mt_node="origin_leaf">N</em><!--volctrans extension anchor for patchId=694-->-dimensional index.
                      Each integer array represents a number
                      of indices into that dimension.</p>
                    <p mt_node="trans">整数数组索引 允许根据N维索引 选择数组中的任意项。每个整数数组表示 该维度 的若干个索引。</p>
                    <p mt_node="origin_leaf">Negative values are permitted in the index arrays and work as they do with
                      single indices or slices:</p>
                    <p mt_node="trans">索引数组中允许使用负值，其作用与在单索引或切片中的作用相同：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([10,  9,  8,  7,  6,  5,  4,  3,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">])]</span>
<span class="go">array([7, 7, 9, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">])]</span>
<span class="go">array([7, 7, 4, 2])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=700-->If the index values are
                      out of bounds then an <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">IndexError</span></code><!--volctrans extension anchor for patchId=702-->
                      is thrown:</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=700-->如果索引值超出范围，则抛出<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">IndexError</span></code><!--volctrans extension anchor for patchId=702-->：
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
<span class="go">array([[3, 4],</span>
<span class="go">      [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 3 is out of bounds for axis 0 with size 3</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">When the index consists of as many integer arrays as dimensions of the
                      array
                      being indexed, the indexing is straightforward, but different from slicing.</p>
                    <p mt_node="trans">当索引是由 与被索引数组的维数一样多的整数数组组成时，索引很简单，但与切片不同。</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=708-->Advanced indices always
                      are <a class="reference internal"
                        href="https://numpy.org/doc/stable/user/basics.broadcasting.html#basics-broadcasting"
                        mt_node="origin_leaf"><span class="std std-ref"
                          mt_node="origin_leaf">broadcast</span></a><!--volctrans extension anchor for patchId=711-->
                      and
                      iterated as <em mt_node="origin_leaf">one</em><!--volctrans extension anchor for patchId=713-->:
                    </p>
                    <p mt_node="trans">高级索引总是作为一个整体进行广播和迭代：</p>
                    <p mt_node="trans">上面这句话的意思是，无论高级索引是什么类型，它们都将被视为一个整体，并且在广播（Broadcasting）和迭代（Iteration）过程中也会被视为一个整体。例如，如果使用两个不同形状的数组进行高级索引，它们将被视为一个整体，并且将根据广播规则进行广播以匹配要索引的数组的形状。</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="n">result</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">ind_1</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">],</span> <span class="n">ind_2</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">],</span>
                           <span class="o">...</span><span class="p">,</span> <span class="n">ind_N</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">]]</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=718-->Note that the resulting
                      shape is identical to the (broadcast) indexing array
                      shapes <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ind_1,</span> <span class="pre">...,</span> <span class="pre">ind_N</span></code><!--volctrans extension anchor for patchId=720-->.
                      If the indices cannot be broadcast to the
                      same shape, an exception <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">IndexError:</span> <span class="pre">shape</span> <span class="pre">mismatch:</span> <span class="pre">indexing</span> <span class="pre">arrays</span> <span class="pre">could</span>
<span class="pre">not</span> <span class="pre">be</span> <span class="pre">broadcast</span> <span class="pre">together</span> <span class="pre">with</span> <span class="pre">shapes...</span></code><!--volctrans extension anchor for patchId=722-->
                      is raised.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=718-->注意，得到的结果的形状与（广播）索引数组的形状
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">ind_1,</span> <span class="pre">...,</span> <span class="pre">ind_N</span></code><!--volctrans extension anchor for patchId=720-->相同。如果索引不能广播到
                      相同的形状，将引发一个异常<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">IndexError:</span> <span class="pre">shape</span> <span class="pre">mismatch:</span> <span class="pre">indexing</span> <span class="pre">arrays</span> <span class="pre">could</span>
<span class="pre">not</span> <span class="pre">be</span> <span class="pre">broadcast</span> <span class="pre">together</span> <span class="pre">with</span> <span class="pre">shapes...</span></code><!--volctrans extension anchor for patchId=722-->。
                    </p>
                    <p mt_node="origin_leaf">Indexing with multidimensional index arrays tend
                      to be more unusual uses, but they are permitted, and they are useful for some
                      problems. We’ll start with the simplest multidimensional case:</p>
                    <p mt_node="trans">使用多维索引数组进行索引往往是不太常见的用法，但它们是允许的，并且它们对某些问题很有用。我们将从最简单的多维案例开始：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5,  6],</span>
<span class="go">       [ 7,  8,  9, 10, 11, 12, 13],</span>
<span class="go">       [14, 15, 16, 17, 18, 19, 20],</span>
<span class="go">       [21, 22, 23, 24, 25, 26, 27],</span>
<span class="go">       [28, 29, 30, 31, 32, 33, 34]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>
<span class="go">array([ 0, 15, 30])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=728-->In this case, if the index
                      arrays have a matching shape, and there is an
                      index array for each dimension of the array being indexed, the resultant
                      array has the same shape as the index arrays, and the values correspond
                      to the index set for each position in the index arrays. In this example,
                      the first index value is 0 for both index arrays, and thus the first value
                      of the resultant array is <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">y[0,</span> <span class="pre">0]</span></code><!--volctrans extension anchor for patchId=730-->.
                      The next value is <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">y[2,</span> <span class="pre">1]</span></code><!--volctrans extension anchor for patchId=732-->,
                      and
                      the last is <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">y[4,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=734-->.
                    </p>
                    <p mt_node="trans">在这种情况下，如果索引数组具有匹配的形状，并且对于被索引的数组的每个维度都有一个索引数组，则结果数组与索引数组具有相同的形状，并且值对应于索引数组中每个位置的索引集。
                      在本例中，两个索引数组的第一个索引值都是0，因此结果数组的第一个值是
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">y[0,</span> <span class="pre">0]</span></code><!--volctrans extension anchor for patchId=730-->。下一个值是<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">y[2,</span> <span class="pre">1]</span></code><!--volctrans extension anchor for patchId=732-->，最后一个值是<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">y[4,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=734-->。
                    </p>
                    <p mt_node="origin_leaf">If the index arrays do not have the same shape, there is an attempt to
                      broadcast them to the same shape. If they cannot be broadcast to the same
                      shape, an exception is raised:</p>
                    <p mt_node="trans">如果索引数组的形状不相同，则会尝试将它们广播为相同的形状。如果它们不能广播到相同的形状，则会引发异常:</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">shape mismatch: indexing arrays could not be broadcast</span>
<span class="x">together with shapes (3,) (2,)</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">The broadcasting mechanism permits index arrays to be combined with
                      scalars for other indices. The effect is that the scalar value is used
                      for all the corresponding values of the index arrays:</p>
                    <p mt_node="trans">广播机制允许索引数组与其他索引的标量结合使用。其效果是标量值被用于索引数组的所有对应值:</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([ 1, 15, 29])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">Jumping to the next level of complexity, it is possible to only partially
                      index an array with index arrays. It takes a bit of thought to understand
                      what happens in such cases. For example if we just use one index array
                      with y:</p>
                    <p mt_node="trans">下面跳转到下一个复杂级别，可以使用索引数组对数组进行部分索引。了解在这种情况下会发生什么，需要一点思考。例如，如果我们只对y使用一个索引数组：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])]</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5,  6],</span>
<span class="go">      [14, 15, 16, 17, 18, 19, 20],</span>
<span class="go">      [28, 29, 30, 31, 32, 33, 34]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">It results in the construction of a new array where each value of the
                      index array selects one row from the array being indexed and the resultant
                      array has the resulting shape (number of index elements, size of row).</p>
                    <p mt_node="trans">这将导致构造一个新数组，其中索引数组的每个值从被索引的数组中选择一行，并且结果数组具有相应的形状(索引元素的数量、行的尺寸)。</p>
                    <p mt_node="origin_leaf">In general, the shape of the resultant array will be the concatenation of
                      the shape of the index array (or the shape that all the index arrays were
                      broadcast to) with the shape of any unused dimensions (those not indexed)
                      in the array being indexed.</p>
                    <p mt_node="trans">一般来说，结果数组的形状将是索引数组的形状(或所有索引数组被广播后的形状)与索引的数组中未使用的维度(未被索引的维度)的形状的连接</p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=751-->From each row, a specific
                      element should be selected. The row index is just
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=753-->
                      and the column index specifies the element to choose for the
                      corresponding row, here <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code><!--volctrans extension anchor for patchId=755-->.
                      Using both together the task
                      can be solved using advanced indexing:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=751-->从每行中选择一个特定的元素。行索引是
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=753-->，列索引指定为对应行选择的元素，这里是<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code><!--volctrans extension anchor for patchId=755-->。将两者结合使用，系统将使用高级索引来解决此任务:
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="go">array([1, 4, 5])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=760-->To achieve a behaviour
                      similar to the basic slicing above, broadcasting can be
                      used. The function <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="origin_leaf"><code
                          class="xref py py-func docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=763-->
                      can help with this broadcasting. This is best
                      understood with an example.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=760-->要实现类似于上面基本切片的行为，可以使用广播。函数<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="trans"><code class="xref py py-func docutils literal notranslate"
                          mt_node="trans"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=763-->可以帮助进行这种广播。通过一个例子可以更好地理解这一点。</p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=766-->From a 4x3 array the
                      corner elements should be selected using advanced
                      indexing. Thus all elements for which the column is one of <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">[0,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=768-->
                      and
                      the row is one of <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">[0,</span> <span class="pre">3]</span></code><!--volctrans extension anchor for patchId=770-->
                      need to be selected. To use advanced indexing
                      one needs to select all elements <em
                        mt_node="origin_leaf">explicitly</em><!--volctrans extension anchor for patchId=772-->. Using
                      the method explained
                      previously one could write:</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=766-->从一个4x3数组中，选择数组角元素，应该使用高级索引来选择。因此，需要选择列值为<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">[0,</span> <span class="pre">2]</span></code><!--volctrans extension anchor for patchId=768-->，
                        行值为<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">[0,</span> <span class="pre">3]</span></code><!--volctrans extension anchor for patchId=770-->的所有元素。要使用高级索引
                      需要<em mt_node="trans">显式地</em><!--volctrans extension anchor for patchId=772-->选择所有元素。使用前面解释的方法，我们可以这样写:</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=777-->However, since the
                      indexing arrays above just repeat themselves,
                      broadcasting can be used (compare operations such as
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">rows[:,</span> <span class="pre">np.newaxis]</span> <span class="pre">+</span> <span class="pre">columns</span></code><!--volctrans extension anchor for patchId=779-->)
                      to simplify this:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=777-->但是，由于上面的索引数组只是重复自己，因此可以使用广播（例如
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">rows[:,</span> <span class="pre">np.newaxis]</span> <span class="pre">+</span> <span class="pre">columns</span></code><!--volctrans extension anchor for patchId=779-->）来简化这一点：
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">array([[0],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=784-->This broadcasting can also
                      be achieved using the function <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="origin_leaf"><code
                          class="xref py py-func docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=787-->:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=784-->这种广播也可以使用<a
                        class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="trans"><code class="xref py py-func docutils literal notranslate"
                          mt_node="trans"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=787-->函数来实现：
                    </p>
                    <div class="doctest highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=792-->Note that without the
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=794-->
                      call, only the diagonal elements would
                      be selected:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=792-->请注意，如果没使用<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=794-->函数，则将只有对角线元素会被选中：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([ 0, 11])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">This difference is the most important thing to remember about
                      indexing with multiple advanced indices.</p>
                    <p mt_node="trans">在使用多个高级索引进行索引时，一定要记住这个区别。</p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf">A real-life example of where advanced indexing may be useful is for a color
                      lookup table where we want to map the values of an image into RGB triples for
                      display. The lookup table could have a shape (nlookup, 3). Indexing
                      such an array with an image with shape (ny, nx) with dtype=np.uint8
                      (or any integer type so long as values are with the bounds of the
                      lookup table) will result in an array of shape (ny, nx, 3) where a
                      triple of RGB values is associated with each pixel location.</p>
                    <p mt_node="trans">
                      高级索引在现实生活中，可能用于的一个例子是，用于“颜色查找表”，在这种情况下，我们希望将图像的值映射到RGB三元组以进行显示。
                      查找表具有形状(nlookup, 3)。使用形状为(ny, nx)、数据类型为np.uint8（或任何整数类型，只要值在查找表的范围内）的图像，对这样的数组进行索引，将得到形状为(ny, nx, 3)的数组，其中每个像素位置都关联着一个RGB值的三元组。</p>
                  </section>
                  <section id="boolean-array-indexing" mt_node="origin">
                    <span id="boolean-indexing" mt_node="origin_leaf"></span><span id="boolean-indexing" mt_node="trans"
                      style="margin: 0px 5px;"></span>
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=804-->Boolean array indexing<a
                        class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=804-->布尔数组索引<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=807-->This advanced indexing
                      occurs when <em mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=809--> is
                      an array object of Boolean
                      type, such as may be returned from comparison operators. A single
                      boolean index array is practically identical to <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[obj.nonzero()]</span></code><!--volctrans extension anchor for patchId=811-->
                      where,
                      as described above, <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                        title="numpy.ndarray.nonzero" mt_node="origin_leaf"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">obj.nonzero()</span></code></a><!--volctrans extension anchor for patchId=814-->
                      returns a
                      tuple (of length <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim"
                        title="numpy.ndarray.ndim" mt_node="origin_leaf"><code
                          class="xref py py-attr docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">obj.ndim</span></code></a><!--volctrans extension anchor for patchId=817-->)
                      of integer index
                      arrays showing the <a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"
                        mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">True</span></code></a><!--volctrans extension anchor for patchId=820-->
                      elements of <em mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=822-->.
                      However, it is
                      faster when <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">obj.shape</span> <span class="pre">==</span> <span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=824-->.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=807-->这种高级索引发生在索引 <em
                        mt_node="trans">obj</em><!--volctrans extension anchor for patchId=809--> 是布尔类型的数组对象时，例如可能从比较操作符返回的数组对象。一个单独的布尔索引数组实际上等同于<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[obj.nonzero()]</span></code><!--volctrans extension anchor for patchId=811-->（这里x是被索引数组；obj是索引），
                        其中，如上所述，<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                        title="numpy.ndarray.nonzero" mt_node="trans"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="trans"><span class="pre">obj.nonzero()</span></code></a><!--volctrans extension anchor for patchId=814-->返回一个由整数索引数组组成的元组（长度为<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim"
                        title="numpy.ndarray.ndim" mt_node="trans"><code
                          class="xref py py-attr docutils literal notranslate"
                          mt_node="trans"><span class="pre">obj.ndim</span></code></a><!--volctrans extension anchor for patchId=817-->）
                      显示<a class="reference external" href="https://docs.python.org/3/library/constants.html#True"
                        title="(in Python v3.11)"
                        mt_node="trans"></a><!--volctrans extension anchor for patchId=820--> <em
                        mt_node="trans">obj</em> <!--volctrans extension anchor for patchId=822-->的<code
                        class="xref py py-data docutils literal notranslate"
                        mt_node="trans"><span class="pre">True</span></code>元素。
                        但是，当<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">obj.shape</span> <span class="pre">==</span> <span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=824-->时，速度更快。
                    </p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=826-->If <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">obj.ndim</span> <span class="pre">==</span> <span class="pre">x.ndim</span></code><!--volctrans extension anchor for patchId=828-->,
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=830-->
                      returns a 1-dimensional array filled with the elements of <em
                        mt_node="origin_leaf">x</em><!--volctrans extension anchor for patchId=832-->
                      corresponding to the <a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"
                        mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">True</span></code></a><!--volctrans extension anchor for patchId=835-->
                      values of <em mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=837-->. The
                      search order
                      will be <a class="reference internal"
                        href="https://numpy.org/doc/stable/glossary.html#term-row-major" mt_node="origin_leaf"><span
                          class="xref std std-term"
                          mt_node="origin_leaf">row-major</span></a><!--volctrans extension anchor for patchId=840-->,
                      C-style. An index error will be raised if
                      the shape of <em mt_node="origin_leaf">obj</em><!--volctrans extension anchor for patchId=842-->
                      does not match the corresponding dimensions of <em
                        mt_node="origin_leaf">x</em><!--volctrans extension anchor for patchId=844-->,
                      regardless of whether those values are <a class="reference external"
                        href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"
                        mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">True</span></code></a><!--volctrans extension anchor for patchId=847-->
                      or
                      <a class="reference external" href="https://docs.python.org/3/library/constants.html#False"
                        title="(in Python v3.11)" mt_node="origin_leaf"><code
                          class="xref py py-data docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">False</span></code></a><!--volctrans extension anchor for patchId=850-->.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=826-->如果<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">obj.ndim</span> <span class="pre">==</span> <span class="pre">x.ndim</span></code><!--volctrans extension anchor for patchId=828-->，则<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[obj]</span></code><!--volctrans extension anchor for patchId=830-->
                      返回一个一维数组，其中包含 <em mt_node="trans">x</em><!--volctrans extension anchor for patchId=832-->
                      中与<a class="reference external" href="https://docs.python.org/3/library/constants.html#True"
                        title="(in Python v3.11)"
                        mt_node="trans"></a><!--volctrans extension anchor for patchId=835--> <em
                        mt_node="trans">obj</em> <!--volctrans extension anchor for patchId=837-->的<code
                        class="xref py py-data docutils literal notranslate"
                        mt_node="trans"><span class="pre">True</span></code>值相对应的元素。搜索顺序将是<a class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-row-major"
                        mt_node="trans">行</a><!--volctrans extension anchor for patchId=840-->为主的，C风格。如果obj<em mt_node="trans">的形状</em><!--volctrans extension anchor for patchId=842-->与<em
                        mt_node="trans">x</em><!--volctrans extension anchor for patchId=844-->的相应尺寸不匹配，则会引发索引错误，
                        无论这些值是<a class="reference external" href="https://docs.python.org/3/library/constants.html#True"
                        title="(in Python v3.11)" mt_node="trans"><code
                          class="xref py py-data docutils literal notranslate"
                          mt_node="trans"><span class="pre">True</span></code></a><!--volctrans extension anchor for patchId=847-->还是
                      <a class="reference external" href="https://docs.python.org/3/library/constants.html#False"
                        title="(in Python v3.11)" mt_node="trans"><code
                          class="xref py py-data docutils literal notranslate"
                          mt_node="trans"><span class="pre">False</span></code></a><!--volctrans extension anchor for patchId=850-->。
                    </p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=852-->A common use case for this
                      is filtering for desired element values.
                      For example, one may wish to select all entries from an array which
                      are not <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.NaN" title="numpy.NaN"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">NaN</span></code></a><!--volctrans extension anchor for patchId=855-->:
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=852-->一个常见的用例(使用方法)是过滤所需的元素值。
                      例如，你可能希望选择数组中所有非<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.NaN" title="numpy.NaN"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">NaN</span></code></a><!--volctrans extension anchor for patchId=855-->的项：
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([1., 2., 3.])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">Or wish to add a constant to all negative elements:</p>
                    <p mt_node="trans">或者希望给所有的负元素加一个常数：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1., 19., 18., 3.])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=864-->In general if an index
                      includes a Boolean array, the result will be
                      identical to inserting <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">obj.nonzero()</span></code><!--volctrans extension anchor for patchId=866-->
                      into the same position
                      and using the integer array indexing mechanism described above.
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[ind_1,</span> <span class="pre">boolean_array,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=868-->
                      is equivalent to
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[(ind_1,)</span> <span class="pre">+</span> <span class="pre">boolean_array.nonzero()</span> <span class="pre">+</span> <span class="pre">(ind_2,)]</span></code><!--volctrans extension anchor for patchId=870-->.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=864-->一般来说，如果索引包含布尔数组，则结果将是与，将<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">obj.nonzero()</span></code><!--volctrans extension anchor for patchId=866-->插入相同位置 并使用上述整数数组索引机制相同。
                      所以<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[ind_1,</span> <span class="pre">boolean_array,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=868-->等价于
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[(ind_1,)</span> <span class="pre">+</span> <span class="pre">boolean_array.nonzero()</span> <span class="pre">+</span> <span class="pre">(ind_2,)]</span></code><!--volctrans extension anchor for patchId=870-->。
                    </p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=872-->If there is only one
                      Boolean array and no integer indexing array present,
                      this is straightforward. Care must only be taken to make sure that the
                      boolean index has <em
                        mt_node="origin_leaf">exactly</em><!--volctrans extension anchor for patchId=874--> as many
                      dimensions as it is supposed to work
                      with.</p>
                    <p mt_node="trans">如果只有一个布尔数组而不存在整数索引数组，那么这种情况处理起来就比较简单，但这种情况 需要注意确保布尔索引的维数与它应该处理的维数完全相同。</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=876-->In general, when the
                      boolean array has fewer dimensions than the array being
                      indexed, this is equivalent to <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[b,</span> <span class="pre">...]</span></code><!--volctrans extension anchor for patchId=878-->,
                      which means x is indexed by b
                      followed by as many <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=880-->
                      as are needed to fill out the rank of x. Thus the
                      shape of the result is one dimension containing the number of True elements of
                      the boolean array, followed by the remaining dimensions of the array being
                      indexed:</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=876-->一般来说，当布尔数组的维度比被索引的数组的维度少时，这等同于<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[b,</span> <span class="pre">...]</span></code><!--volctrans extension anchor for patchId=878-->，这意味着x通过b进行索引，然后跟随尽可能多的<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=880-->来填满 x 的剩余维度。因此，结果的形状是一个一维的数组，包含布尔数组中True元素的数量，然后跟随被索引的数组的剩余维度：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span>
<span class="go">array([False, False, False,  True,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="go">array([[21, 22, 23, 24, 25, 26, 27],</span>
<span class="go">      [28, 29, 30, 31, 32, 33, 34]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">Here the 4th and 5th rows are selected from the indexed array and
                      combined to make a 2-D array.</p>
                    <p mt_node="trans">在这里，从索引数组中选择第4行和第5行，并将它们组合成一个二维数组。</p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf">From an array, select all rows which sum up to less or equal two:</p>
                    <p mt_node="trans">从一个数组中，选择 所有加起来小于等于2的行 :</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rowsum</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rowsum</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 1]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=891-->Combining multiple Boolean
                      indexing arrays or a Boolean with an integer
                      indexing array can best be understood with the
                      <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                        title="numpy.ndarray.nonzero" mt_node="origin_leaf"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">obj.nonzero()</span></code></a><!--volctrans extension anchor for patchId=894-->
                      analogy. The function <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="origin_leaf"><code
                          class="xref py py-func docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=897-->
                      also supports boolean arrays and will work without any surprises.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=891-->将多个布尔索引数组或一个布尔值与一个整数索引数组组合，最好使用
                      <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                        title="numpy.ndarray.nonzero" mt_node="trans"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="trans"><span class="pre">obj.nonzero()</span></code></a><!--volctrans extension anchor for patchId=894-->类比来理解。<a
                        class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="trans"><code class="xref py py-func docutils literal notranslate"
                          mt_node="trans"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=897-->
                          函数也支持布尔数组，并且可以正常工作，不会产生任何意外。
                    </p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=900-->Use boolean indexing to
                      select all rows adding up to an even
                      number. At the same time columns 0 and 2 should be selected with an
                      advanced integer index. Using the <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="origin_leaf"><code
                          class="xref py py-func docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=903-->
                      function this can be done
                      with:</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=900-->使用布尔索引选择所有加起来为偶数的行。同时使用高级整数索引选择第0列和第2列。使用<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_"
                        title="numpy.ix_" mt_node="trans"><code class="xref py py-func docutils literal notranslate"
                          mt_node="trans"><span class="pre">ix_</span></code></a><!--volctrans extension anchor for patchId=903-->函数可以完成此操作：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span>
<span class="go">array([False,  True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=908-->Without the <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=910-->
                      call, only the diagonal elements would be
                      selected.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=908-->如果没有<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=910-->调用，将只选择对角线元素。</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=912-->Or without <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=914-->
                      (compare the integer array examples):</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=912-->或者不带<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">np.ix_</span></code><!--volctrans extension anchor for patchId=914-->（比较整数数组的例子）：
                    </p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre>
                      </div>
                    </div>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf">Use a 2-D boolean array of shape (2, 3)
                      with four True elements to select rows from a 3-D array of shape
                      (2, 3, 5) results in a 2-D result of shape (4, 5):</p>
                    <p mt_node="trans">使用形状为(2,3)的二维布尔数组，其中包含四个True元素，从形状为(2,3,5)的3维数组中选择行，结果是形状为(4,5)的二维数组</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0,  1,  2,  3,  4],</span>
<span class="go">        [ 5,  6,  7,  8,  9],</span>
<span class="go">        [10, 11, 12, 13, 14]],</span>
<span class="go">      [[15, 16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23, 24],</span>
<span class="go">        [25, 26, 27, 28, 29]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">      [ 5,  6,  7,  8,  9],</span>
<span class="go">      [20, 21, 22, 23, 24],</span>
<span class="go">      [25, 26, 27, 28, 29]])</span>
</pre>
                      </div>
                    </div>
                  </section>
                  <section id="combining-advanced-and-basic-indexing" mt_node="origin">
                    <span id="id6" mt_node="origin_leaf"></span><span id="id6" mt_node="trans"
                      style="margin: 0px 5px;"></span>
                    <h3 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=926-->Combining advanced and
                      basic indexing<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#combining-advanced-and-basic-indexing"
                        title="Permalink to this heading" mt_node="origin_leaf">#</a></h3>
                    <h3 mt_node="trans"><!--volctrans extension anchor for patchId=926-->高级索引和基本索引相结合<a class="headerlink"
                        href="https://numpy.org/doc/stable/user/basics.indexing.html#combining-advanced-and-basic-indexing"
                        title="Permalink to this heading" mt_node="trans">#</a></h3>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=929-->When there is at least one
                      slice (<code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=931-->),
                      ellipsis (<code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">...</span></code><!--volctrans extension anchor for patchId=933-->)
                      or <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="origin_leaf"><code class="xref py py-const docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=936-->
                      in the index (or the array has more dimensions than there are advanced indices),
                      then the behaviour can be more complicated. It is like concatenating the
                      indexing result for each advanced index element.</p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=929-->当索引中至少存在一个切片（<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=931-->）、省略号（<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">...</span></code><!--volctrans extension anchor for patchId=933-->）或<a
                        class="reference internal"
                        href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" title="numpy.newaxis"
                        mt_node="trans"><code class="xref py py-const docutils literal notranslate"
                          mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=936-->
                      （或者数组的维度多于高级索引的数量）时，那么行为可能会更复杂。这类似于将每个高级索引元素的索引结果连接起来。</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=938-->In the simplest case,
                      there is only a <em
                        mt_node="origin_leaf">single</em><!--volctrans extension anchor for patchId=940--> advanced
                      index combined with
                      a slice. For example:</p>
                    <p mt_node="trans">在最简单的情况下，只有一个高级索引与一个切片相结合。例如：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[ 1,  2],</span>
<span class="go">       [15, 16],</span>
<span class="go">       [29, 30]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">In effect, the slice and index array operation are independent. The slice
                      operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns),
                      followed by the index array operation which extracts rows with index 0, 2 and 4
                      (i.e the first, third and fifth rows). This is equivalent to:</p>
                    <p mt_node="trans">
                      实际上，切片操作和索引数组操作是独立的。切片操作提取索引为1和2的列(即第二和第三列)，然后是索引数组操作，提取索引为0、2和4的行(即第一、第三和第五行)。这相当于：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">:]</span>
<span class="go">array([[ 1,  2],</span>
<span class="go">       [15, 16],</span>
<span class="go">       [29, 30]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf">A single advanced index can, for example, replace a slice and the result
                      array
                      will be the same. However, it is a copy and may have a different memory layout.
                      A slice is preferable when it is possible.
                      For example:</p>
                    <p mt_node="trans">例如，单个高级索引可以替换切片，且结果数组将是相同的。但是，它是一个副本，可能具有不同的内存布局。在可能的情况下，尽可能使用切片。例如：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="go">array([[4, 5]])</span>
</pre>
                      </div>
                    </div>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=953-->The easiest way to
                      understand a combination of <em
                        mt_node="origin_leaf">multiple</em><!--volctrans extension anchor for patchId=955--> advanced
                      indices may
                      be to think in terms of the resulting shape. There are two parts to the indexing
                      operation, the subspace defined by the basic indexing (excluding integers) and
                      the subspace from the advanced indexing part. Two cases of index combination
                      need to be distinguished:</p>
                    <p mt_node="trans">
                      理解多个高级索引组合的最简单方法可能是根据生成的结果形状进行思考。索引操作分为两部分，一部分是由基本索引（不包括整数）所定义的子空间，另一部分是由高级索引部分定义的子空间。需要区分两种索引组合的情况：</p>
                    <ul class="simple" mt_node="origin">
                      <li mt_node="origin">
                        <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=959-->The advanced indices
                          are separated by a slice, <a class="reference external"
                            href="https://docs.python.org/3/library/constants.html#Ellipsis" title="(in Python v3.11)"
                            mt_node="origin_leaf"><code class="xref py py-data docutils literal notranslate"
                              mt_node="origin_leaf"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=962-->
                          or
                          <a class="reference internal"
                            href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis"
                            title="numpy.newaxis" mt_node="origin_leaf"><code
                              class="xref py py-const docutils literal notranslate"
                              mt_node="origin_leaf"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=965-->.
                          For example <code class="docutils literal notranslate"
                            mt_node="origin_leaf"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">arr2]</span></code><!--volctrans extension anchor for patchId=967-->.
                        </p>
                        <p mt_node="trans"><!--volctrans extension anchor for patchId=959-->高级索引可以通过切片、<a
                            class="reference external" href="https://docs.python.org/3/library/constants.html#Ellipsis"
                            title="(in Python v3.11)" mt_node="trans"><code
                              class="xref py py-data docutils literal notranslate"
                              mt_node="trans"><span class="pre">Ellipsis</span></code></a><!--volctrans extension anchor for patchId=962-->或
                          <a class="reference internal"
                            href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis"
                            title="numpy.newaxis" mt_node="trans"><code
                              class="xref py py-const docutils literal notranslate"
                              mt_node="trans"><span class="pre">newaxis</span></code></a><!--volctrans extension anchor for patchId=965-->进行分割。例如 <code
                            class="docutils literal notranslate"
                            mt_node="trans"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">arr2]</span></code><!--volctrans extension anchor for patchId=967-->。
                        </p>
                      </li>
                      <li mt_node="origin">
                        <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=970-->The advanced indices
                          are all next to each other.
                          For example <code class="docutils literal notranslate"
                            mt_node="origin_leaf"><span class="pre">x[...,</span> <span class="pre">arr1,</span> <span class="pre">arr2,</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=972-->
                          but <em mt_node="origin_leaf">not</em> <code class="docutils literal notranslate"
                            mt_node="origin_leaf"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">1]</span></code><!--volctrans extension anchor for patchId=975-->
                          since <code class="docutils literal notranslate"
                            mt_node="origin_leaf"><span class="pre">1</span></code><!--volctrans extension anchor for patchId=977-->
                          is an advanced index in this regard.</p>
                        <p mt_node="trans"><!--volctrans extension anchor for patchId=970-->这些高级索引都是彼此相邻的。例如<code class="docutils literal notranslate"
                            mt_node="trans"><span class="pre">x[...,</span> <span class="pre">arr1,</span> <span class="pre">arr2,</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=972-->但不包括 <code class="docutils literal notranslate"
                            mt_node="trans"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">1]</span></code><!--volctrans extension anchor for patchId=975-->
                          因为<code class="docutils literal notranslate"
                            mt_node="trans"><span class="pre">1</span></code><!--volctrans extension anchor for patchId=977-->在这里面是一个高级索引。
                        </p>
                      </li>
                    </ul>
                    <p mt_node="origin_leaf">In the first case, the dimensions resulting from the advanced indexing
                      operation come first in the result array, and the subspace dimensions after
                      that.
                      In the second case, the dimensions from the advanced indexing operations
                      are inserted into the result array at the same spot as they were in the
                      initial array (the latter logic is what makes simple advanced indexing
                      behave just like slicing).</p>
                    <p mt_node="trans">
                      在第一种情况下，高级索引操作产生的维度首先出现在结果数组中，然后是子空间维度。在第二种情况下，高级索引操作所得到的维度被插入到结果数组中，插入位置与它们在初始数组中的位置相同（后一种逻辑使简单的高级索引的行为类似于切片）。
                    </p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=981-->Suppose <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=983-->
                      is (10, 20, 30) and <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ind</span></code><!--volctrans extension anchor for patchId=985-->
                      is a (2, 3, 4)-shaped
                      indexing <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.intp" title="numpy.intp"
                        mt_node="origin_leaf"><code class="xref py py-class docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">intp</span></code></a><!--volctrans extension anchor for patchId=988-->
                      array, then <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">x[...,</span> <span class="pre">ind,</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=990-->
                      has
                      shape (10, 2, 3, 4, 30) because the (20,)-shaped subspace has been
                      replaced with a (2, 3, 4)-shaped broadcasted indexing subspace. If
                      we let <em mt_node="origin_leaf">i, j, k</em><!--volctrans extension anchor for patchId=992-->
                      loop over the (2, 3, 4)-shaped subspace then
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">result[...,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">k,</span> <span class="pre">:]</span> <span class="pre">=</span> <span class="pre">x[...,</span> <span class="pre">ind[i,</span> <span class="pre">j,</span> <span class="pre">k],</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=994-->.
                      This example
                      produces the same result as <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.take.html#numpy.ndarray.take"
                        title="numpy.ndarray.take" mt_node="origin_leaf"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">x.take(ind,</span> <span class="pre">axis=-2)</span></code></a><!--volctrans extension anchor for patchId=997-->.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=981-->假设<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=983-->是（10,20,30），<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">ind</span></code><!--volctrans extension anchor for patchId=985-->是一个形状为（2,3,4）的<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.intp" title="numpy.intp"
                        mt_node="trans"><code class="xref py py-class docutils literal notranslate"
                          mt_node="trans"><span class="pre">intp</span></code></a><!--volctrans extension anchor for patchId=988-->（整数）类型的索引数组，那么<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">x[...,</span> <span class="pre">ind,</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=990-->的形状为（10,2,3,4,30），因为形状为（20，）的下标空间被替换为一个形状为（2,3,4）的广播索引子空间。如果我们让<em mt_node="trans">i，j，k</em><!--volctrans extension anchor for patchId=992-->在形状为（2,3,4）的子空间上循环遍历
                        ，则<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">result[...,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">k,</span> <span class="pre">:]</span> <span class="pre">=</span> <span class="pre">x[...,</span> <span class="pre">ind[i,</span> <span class="pre">j,</span> <span class="pre">k],</span> <span class="pre">:]</span></code><!--volctrans extension anchor for patchId=994-->。这个例子与<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.take.html#numpy.ndarray.take"
                        title="numpy.ndarray.take" mt_node="trans"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="trans"><span class="pre">x.take(ind,</span> <span class="pre">axis=-2)</span></code></a><!--volctrans extension anchor for patchId=997-->产生相同的结果。
                    </p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1000-->Let <code
                        class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=1002-->
                      be (10, 20, 30, 40, 50) and suppose <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ind_1</span></code><!--volctrans extension anchor for patchId=1004-->
                      and <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ind_2</span></code><!--volctrans extension anchor for patchId=1006-->
                      can be broadcast to the shape (2, 3, 4). Then
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[:,</span> <span class="pre">ind_1,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=1008-->
                      has shape (10, 2, 3, 4, 40, 50) because the
                      (20, 30)-shaped subspace from X has been replaced with the
                      (2, 3, 4) subspace from the indices. However,
                      <code class="docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x[:,</span> <span class="pre">ind_1,</span> <span class="pre">:,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=1010-->
                      has shape (2, 3, 4, 10, 30, 50) because there
                      is no unambiguous place to drop in the indexing subspace, thus
                      it is tacked-on to the beginning. It is always possible to use
                      <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose"
                        title="numpy.ndarray.transpose" mt_node="origin_leaf"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">.transpose()</span></code></a><!--volctrans extension anchor for patchId=1013-->
                      to move the subspace
                      anywhere desired. Note that this example cannot be replicated
                      using <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.take.html#numpy.take"
                        title="numpy.take" mt_node="origin_leaf"><code
                          class="xref py py-func docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">take</span></code></a><!--volctrans extension anchor for patchId=1016-->.
                    </p>
                    <p mt_node="trans"><!--volctrans extension anchor for patchId=1000-->假设<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x.shape</span></code><!--volctrans extension anchor for patchId=1002-->为（10,20,30,40,50）并且假设<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">ind_1</span></code><!--volctrans extension anchor for patchId=1004-->
                        和<code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">ind_2</span></code><!--volctrans extension anchor for patchId=1006-->可以广播到形状（2,3,4）。那么
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[:,</span> <span class="pre">ind_1,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=1008-->的形状为（10,2,3,4,40,50），因为
                      X 的（20,30）子空间被替换为索引的
                      （2,3,4）子空间。然而，
                      <code class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x[:,</span> <span class="pre">ind_1,</span> <span class="pre">:,</span> <span class="pre">ind_2]</span></code><!--volctrans extension anchor for patchId=1010-->的形状为（2,3,4,10,30,50）因为在索引子空间中没有明确的放置位置，因此它被附加到开头。这时可以使用
                      <a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose"
                        title="numpy.ndarray.transpose" mt_node="trans"><code
                          class="xref py py-meth docutils literal notranslate"
                          mt_node="trans"><span class="pre">.transpose()</span></code></a><!--volctrans extension anchor for patchId=1013-->将子空间移动到所需的位置。请注意，此示例无法使用<a class="reference internal"
                        href="https://numpy.org/doc/stable/reference/generated/numpy.take.html#numpy.take"
                        title="numpy.take" mt_node="trans"><code class="xref py py-func docutils literal notranslate"
                          mt_node="trans"><span class="pre">take</span></code></a><!--volctrans extension anchor for patchId=1016-->复制。
                    </p>
                    <p class="rubric" mt_node="origin_leaf">Example</p>
                    <p class="rubric" mt_node="trans">示例</p>
                    <p mt_node="origin_leaf">Slicing can be combined with broadcasted boolean indices:</p>
                    <p mt_node="trans">切片可以与广播的布尔索引相结合：</p>
                    <div class="highlight-default notranslate" mt_node="origin">
                      <div class="highlight" mt_node="origin">
                        <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">      [False, False, False, False, False, False, False],</span>
<span class="go">      [False, False, False, False, False, False, False],</span>
<span class="go">      [ True,  True,  True,  True,  True,  True,  True],</span>
<span class="go">      [ True,  True,  True,  True,  True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[22, 23],</span>
<span class="go">      [29, 30]])</span>
</pre>
                      </div>
                    </div>
                  </section>
                </section>
                <section id="field-access" mt_node="origin">
                  <span id="arrays-indexing-fields" mt_node="origin_leaf"></span><span id="arrays-indexing-fields"
                    mt_node="trans" style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1025-->Field access<a
                      class="headerlink" href="https://numpy.org/doc/stable/user/basics.indexing.html#field-access"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=1025-->字段访问<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#field-access"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <div class="admonition seealso" mt_node="origin">
                    <p class="admonition-title" mt_node="origin_leaf">See also</p>
                    <p class="admonition-title" mt_node="trans">又见</p>
                    <p mt_node="origin_leaf"><a class="reference internal"
                        href="https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays"
                        mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">Structured
                          arrays</span></a></p>
                    <p mt_node="trans"><a class="reference internal"
                        href="https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays"
                        mt_node="trans">结构化数组</a></p>
                  </div>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1033-->If the <a
                      class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                      title="numpy.ndarray" mt_node="origin_leaf"><code
                        class="xref py py-class docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">ndarray</span></code></a><!--volctrans extension anchor for patchId=1036-->
                    object is a structured array the <a class="reference internal"
                      href="https://numpy.org/doc/stable/glossary.html#term-field" mt_node="origin_leaf"><span
                        class="xref std std-term"
                        mt_node="origin_leaf">fields</span></a><!--volctrans extension anchor for patchId=1039-->
                    of the array can be accessed by indexing the array with strings,
                    dictionary-like.</p>
                  <p mt_node="trans"><!--volctrans extension anchor for patchId=1033-->如果<a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"
                      title="numpy.ndarray" mt_node="trans"><code class="xref py py-class docutils literal notranslate"
                        mt_node="trans"><span class="pre">ndarray</span></code></a><!--volctrans extension anchor for patchId=1036-->对象是一个结构化数组，则可以通过使用字符串或类似字典的索引方式来访问数组的<a
                      class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-field"
                      mt_node="trans">字段</a><!--volctrans extension anchor for patchId=1039-->。</p>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1041-->Indexing <code
                      class="docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">x['field-name']</span></code><!--volctrans extension anchor for patchId=1043-->
                    returns a new <a class="reference internal"
                      href="https://numpy.org/doc/stable/glossary.html#term-view" mt_node="origin_leaf"><span
                        class="xref std std-term"
                        mt_node="origin_leaf">view</span></a><!--volctrans extension anchor for patchId=1046--> to the
                    array,
                    which is of the same shape as <em
                      mt_node="origin_leaf">x</em><!--volctrans extension anchor for patchId=1048--> (except when the
                    field is a
                    sub-array) but of data type <code class="docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">x.dtype['field-name']</span></code><!--volctrans extension anchor for patchId=1050-->
                    and contains
                    only the part of the data in the specified field. Also,
                    <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/arrays.classes.html#arrays-classes-rec"
                      mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">record
                        array</span></a><!--volctrans extension anchor for patchId=1053--> scalars can be “indexed” this
                    way.
                  </p>
                  <p mt_node="trans"><!--volctrans extension anchor for patchId=1041-->对<code
                      class="docutils literal notranslate"
                      mt_node="trans"><span class="pre">x['field-name']</span></code><!--volctrans extension anchor for patchId=1043-->进行索引会返回数组的新<a
                      class="reference internal" href="https://numpy.org/doc/stable/glossary.html#term-view"
                      mt_node="trans">视图</a><!--volctrans extension anchor for patchId=1046-->，
                      其形状与<em mt_node="trans">x</em><!--volctrans extension anchor for patchId=1048-->相同（除非该字段是子数组），但数据类型为<code class="docutils literal notranslate"
                      mt_node="trans"><span class="pre">x.dtype['field-name']</span></code>，<!--volctrans extension anchor for patchId=1050-->并且只包含指定字段中的部分数据。此外，
                    <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/arrays.classes.html#arrays-classes-rec"
                      mt_node="trans">记录数组</a><!--volctrans extension anchor for patchId=1053-->标量也可以通过这种方式进行“索引”。
                  </p>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1055-->Indexing into a structured
                    array can also be done with a list of field names,
                    e.g. <code class="docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">x[['field-name1',</span> <span class="pre">'field-name2']]</span></code><!--volctrans extension anchor for patchId=1057-->.
                    As of NumPy 1.16, this returns a
                    view containing only those fields. In older versions of NumPy, it returned a
                    copy. See the user guide section on <a class="reference internal"
                      href="https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays"
                      mt_node="origin_leaf"><span class="std std-ref" mt_node="origin_leaf">Structured
                        arrays</span></a><!--volctrans extension anchor for patchId=1060--> for more
                    information on multifield indexing.</p>
                  <p mt_node="trans"><!--volctrans extension anchor for patchId=1055-->对结构化数组的索引也可以通过字段名列表来完成，
                    例如<code class="docutils literal notranslate"
                      mt_node="trans"><span class="pre">x[['field-name1',</span> <span class="pre">'field-name2']]</span></code><!--volctrans extension anchor for patchId=1057-->。从NumPy
                    1.16开始，它将返回一个只包含这些字段的视图。在旧版本的NumPy中，它返回一个副本。有关多字段索引的更多信息，请参阅用户指南中有关<a class="reference internal"
                      href="https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays"
                      mt_node="trans">结构化数组</a><!--volctrans extension anchor for patchId=1060-->的章节。</p>
                  <p mt_node="origin_leaf">If the accessed field is a sub-array, the dimensions of the sub-array
                    are appended to the shape of the result.
                    For example:</p>
                  <p mt_node="trans">如果访问的字段是子数组，则子数组的维度将追加到结果的形状中。例如：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype('int32')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype('float64')</span>
</pre>
                    </div>
                  </div>
                </section>
                <section id="flat-iterator-indexing" mt_node="origin">
                  <span id="id7" mt_node="origin_leaf"></span><span id="id7" mt_node="trans"
                    style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1068-->Flat Iterator indexing<a
                      class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#flat-iterator-indexing"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=1068-->平铺迭代器索引<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#flat-iterator-indexing"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <p mt_node="origin_leaf"><a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flat.html#numpy.ndarray.flat"
                      title="numpy.ndarray.flat" mt_node="origin_leaf"><code
                        class="xref py py-attr docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x.flat</span></code></a><!--volctrans extension anchor for patchId=1073-->
                    returns an iterator that will iterate
                    over the entire array (in C-contiguous style with the last index
                    varying the fastest). This iterator object can also be indexed using
                    basic slicing or advanced indexing as long as the selection object is
                    not a tuple. This should be clear from the fact that <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flat.html#numpy.ndarray.flat"
                      title="numpy.ndarray.flat" mt_node="origin_leaf"><code
                        class="xref py py-attr docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">x.flat</span></code></a><!--volctrans extension anchor for patchId=1076-->
                    is a 1-dimensional view. It can be used for integer
                    indexing with 1-dimensional C-style-flat indices. The shape of any
                    returned array is therefore the shape of the integer indexing object.</p>
                  <p mt_node="trans"><a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flat.html#numpy.ndarray.flat"
                      title="numpy.ndarray.flat" mt_node="trans"><code
                        class="xref py py-attr docutils literal notranslate"
                        mt_node="trans"><span class="pre">x.flat</span></code></a><!--volctrans extension anchor for patchId=1073-->返回一个迭代器，该迭代器将遍历整个数组（以C连续风格，最后一个索引变化最快）。
                        只要选择对象不是元组，此迭代器对象也可以使用基本切片或高级索引进行索引。
                        从<a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flat.html#numpy.ndarray.flat"
                      title="numpy.ndarray.flat" mt_node="trans"><code
                        class="xref py py-attr docutils literal notranslate"
                        mt_node="trans"><span class="pre">x.flat</span></code></a><!--volctrans extension anchor for patchId=1076-->是一维视图这一事实中应该可以清楚地看出这一点。它可以用于1维C-style-flat
                        索引的整数索引。因此，任何返回的数组形状都是整数索引对象的形状。</p>
                </section>
                <section id="assigning-values-to-indexed-arrays" mt_node="origin">
                  <span id="index-3" mt_node="origin_leaf"></span><span id="index-3" mt_node="trans"
                    style="margin: 0px 5px;"></span><span id="id8" mt_node="origin_leaf"></span><span id="id8"
                    mt_node="trans" style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1081-->Assigning values to
                    indexed arrays<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#assigning-values-to-indexed-arrays"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=1081-->为索引数组赋值<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#assigning-values-to-indexed-arrays"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <p mt_node="origin_leaf">As mentioned, one can select a subset of an array to assign to using
                    a single index, slices, and index and mask arrays. The value being
                    assigned to the indexed array must be shape consistent (the same shape
                    or broadcastable to the shape the index produces). For example, it is
                    permitted to assign a constant to a slice:</p>
                  <p mt_node="trans">如前所述，可以使用单个索引、切片以及索引和掩码数组来选择数组的子集进行赋值。赋给已索引数组的值必须是形状一致的（与索引产生的形状相同或可广播）。例如，允许将常量赋值给切片：
                  </p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf">or an array of the right size:</p>
                  <p mt_node="trans">或者一个大小合适的数组：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf">Note that assignments may result in changes if assigning
                    higher types to lower types (like floats to ints) or even
                    exceptions (assigning complex to floats or ints):</p>
                  <p mt_node="trans">请注意，如果将高级类型赋值给低级类型（如将float赋值给int），赋值可能会导致更改甚至是异常：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span><span class="n">j</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">can't convert complex to int</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf">Unlike some of the references (such as array and mask indices)
                    assignments are always made to the original data in the array
                    (indeed, nothing else would make sense!). Note though, that some
                    actions may not work as one may naively expect. This particular
                    example is often surprising to people:</p>
                  <p mt_node="trans">
                    与某些引用不同（例如数组和掩码索引），赋值总是对数组中的原始数据进行赋值（事实上，没有其他任何意义！）。但是请注意，有些操作可能不像人们天真地期望的那样工作。下面这个特定的例子经常会让人们感到惊讶：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 0, 10, 20, 30, 40])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 0, 11, 20, 31, 40])</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1100-->Where people expect that
                    the 1st location will be incremented by 3.
                    In fact, it will only be incremented by 1. The reason is that
                    a new array is extracted from the original (as a temporary) containing
                    the values at 1, 1, 3, 1, then the value 1 is added to the temporary,
                    and then the temporary is assigned back to the original array. Thus
                    the value of the array at <code class="docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">x[1]</span> <span class="pre">+</span> <span class="pre">1</span></code><!--volctrans extension anchor for patchId=1102-->
                    is assigned to <code class="docutils literal notranslate"
                      mt_node="origin_leaf"><span class="pre">x[1]</span></code><!--volctrans extension anchor for patchId=1104-->
                    three times,
                    rather than being incremented 3 times.</p>
                  <p mt_node="trans"><!--volctrans extension anchor for patchId=1100-->人们原本期望第一个位置能够增加3。
                    但实际上，它只会增加1。原因是，从原始数组中提取了一个包含 1,1,3,1 处值的新数组（作为临时数组），然后将1的值加到临时数组中，再将临时数组重新赋值给原始数组。
                    因此，<code class="docutils literal notranslate"
                      mt_node="trans"><span class="pre">x[1]</span> <span class="pre">+</span> <span class="pre">1</span></code><!--volctrans extension anchor for patchId=1102-->的值被赋值给<code
                      class="docutils literal notranslate"
                      mt_node="trans"><span class="pre">x[1]</span></code><!--volctrans extension anchor for patchId=1104-->三次，
                      而不是增加了3次。</p>
                </section>
                <section id="dealing-with-variable-numbers-of-indices-within-programs" mt_node="origin">
                  <span id="dealing-with-variable-indices" mt_node="origin_leaf"></span><span
                    id="dealing-with-variable-indices" mt_node="trans" style="margin: 0px 5px;"></span>
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1108-->Dealing with variable
                    numbers of indices within programs<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#dealing-with-variable-numbers-of-indices-within-programs"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=1108-->在程序中处理可变数量的索引<a
                      class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#dealing-with-variable-numbers-of-indices-within-programs"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <p mt_node="origin_leaf">The indexing syntax is very powerful but limiting when dealing with
                    a variable number of indices. For example, if you want to write
                    a function that can handle arguments with various numbers of
                    dimensions without having to write special case code for each
                    number of possible dimensions, how can that be done? If one
                    supplies to the index a tuple, the tuple will be interpreted
                    as a list of indices. For example:</p>
                  <p mt_node="trans">
                    索引语法功能非常强大，但在处理可变数量的索引时却有限制。例如，如果您想编写一个函数，该函数可以处理具有不同维数的参数，而又不想为每个可能维度编写特殊情况代码，如何做到这一点？如果向索引提供了一个元组，该元组将被解释为索引列表。例如：
                  </p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">81</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">40</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf">So one can use code to construct tuples of any number of indices
                    and then use these within an index.</p>
                  <p mt_node="trans">因此，可以使用代码来构建包含任意数量索引的元组，然后在索引中使用这些元组。</p>
                  <p mt_node="origin_leaf">Slices can be specified within programs by using the slice() function
                    in Python. For example:</p>
                  <p mt_node="trans">在Python程序中，可以使用slice()函数来指定切片。例如：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># same as [1, 1, 1, 0:2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([39, 40])</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf">Likewise, ellipsis can be specified by code by using the Ellipsis
                    object:</p>
                  <p mt_node="trans">同样，省略号也可以通过代码使用Ellipsis对象来指定:</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># same as [1, ..., 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([[28, 31, 34],</span>
<span class="go">       [37, 40, 43],</span>
<span class="go">       [46, 49, 52]])</span>
</pre>
                    </div>
                  </div>
                  <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1124-->For this reason, it is
                    possible to use the output from the
                    <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                      title="numpy.ndarray.nonzero" mt_node="origin_leaf"><code
                        class="xref py py-meth docutils literal notranslate"
                        mt_node="origin_leaf"><span class="pre">np.nonzero()</span></code></a><!--volctrans extension anchor for patchId=1127-->
                    function directly as an index since
                    it always returns a tuple of index arrays.
                  </p>
                  <p mt_node="trans"><!--volctrans extension anchor for patchId=1124-->由于这个原因，可以直接使用
                    <a class="reference internal"
                      href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero"
                      title="numpy.ndarray.nonzero" mt_node="trans"><code
                        class="xref py py-meth docutils literal notranslate"
                        mt_node="trans"><span class="pre">np.nonzero()</span></code></a><!--volctrans extension anchor for patchId=1127-->函数的输出作为索引，因为它总是返回一个索引数组元组。
                  </p>
                  <p mt_node="origin_leaf">Because of the special treatment of tuples, they are not automatically
                    converted to an array as a list would be. As an example:</p>
                  <p mt_node="trans">由于元组的特殊处理，它们不会像列表那样自动转换为数组。举个例子：</p>
                  <div class="highlight-default notranslate" mt_node="origin">
                    <div class="highlight" mt_node="origin">
                      <pre mt_node="origin"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># produces a large array</span>
<span class="go">array([[[[27, 28, 29],</span>
<span class="go">         [30, 31, 32], ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>  <span class="c1"># returns a single value</span>
<span class="go">40</span>
</pre>
                    </div>
                  </div>
                </section>
                <section id="detailed-notes" mt_node="origin">
                  <h2 mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1134-->Detailed notes<a
                      class="headerlink" href="https://numpy.org/doc/stable/user/basics.indexing.html#detailed-notes"
                      title="Permalink to this heading" mt_node="origin_leaf">#</a></h2>
                  <h2 mt_node="trans"><!--volctrans extension anchor for patchId=1134-->详细说明<a class="headerlink"
                      href="https://numpy.org/doc/stable/user/basics.indexing.html#detailed-notes"
                      title="Permalink to this heading" mt_node="trans">#</a></h2>
                  <p mt_node="origin_leaf">These are some detailed notes, which are not of importance for day to day
                    indexing (in no particular order):</p>
                  <p mt_node="trans">以下是一些详细的说明，这些说明对于日常索引来说并不重要（无特定顺序）：</p>
                  <ul class="simple" mt_node="origin">
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1140-->The native NumPy
                        indexing type is <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">intp</span></code><!--volctrans extension anchor for patchId=1142-->
                        and may differ from the
                        default integer array type. <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">intp</span></code><!--volctrans extension anchor for patchId=1144-->
                        is the smallest data type
                        sufficient to safely index any array; for advanced indexing it may be
                        faster than other types.</p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1140-->NumPy的原生索引类型是<code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">intp</span></code><!--volctrans extension anchor for patchId=1142-->，可能与默认的整数数组类型不同。<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">intp</span></code><!--volctrans extension anchor for patchId=1144-->是最小的数据类型，足以安全地索引任何数组；对于高级索引，它可能比其他类型更快。</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf">For advanced assignments, there is in general no guarantee for the
                        iteration order. This means that if an element is set more than once,
                        it is not possible to predict the final result.</p>
                      <p mt_node="trans">对于高级赋值，一般不能保证迭代顺序。这意味着如果一个元素被设置多次，则无法预测最终结果。</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1149-->An empty (tuple) index
                        is a full scalar index into a zero-dimensional array.
                        <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">x[()]</span></code><!--volctrans extension anchor for patchId=1151-->
                        returns a <em
                          mt_node="origin_leaf">scalar</em><!--volctrans extension anchor for patchId=1153--> if <code
                          class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">x</span></code><!--volctrans extension anchor for patchId=1155-->
                        is zero-dimensional and a view
                        otherwise. On the other hand, <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">x[...]</span></code><!--volctrans extension anchor for patchId=1157-->
                        always returns a view.
                      </p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1149-->空（元组）索引是零维数组的全(完整)标量索引。如果<code
                        class="docutils literal notranslate"
                        mt_node="trans"><span class="pre">x</span></code>是零维，
                        <code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">x[()]</span></code><!--volctrans extension anchor for patchId=1151-->返回一个<em
                          mt_node="trans">标量</em><!--volctrans extension anchor for patchId=1153-->，否则返回一个视图。另一方面，<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">x[...]</span></code><!--volctrans extension anchor for patchId=1157-->总是返回一个视图。
                      </p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1160-->If a zero-dimensional
                        array is present in the index <em
                          mt_node="origin_leaf">and</em><!--volctrans extension anchor for patchId=1162--> it is a full
                        integer index the result will be a <em
                          mt_node="origin_leaf">scalar</em><!--volctrans extension anchor for patchId=1164--> and not a
                        zero-dimensional array.
                        (Advanced indexing is not triggered.)</p>
                      <p mt_node="trans">如果索引中存在零维数组，并且它是一个完整的整数索引，则结果将是标量而不是零维数组。（不会触发高级索引。）</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1167-->When an ellipsis (<code
                          class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">...</span></code><!--volctrans extension anchor for patchId=1169-->)
                        is present but has no size (i.e. replaces zero
                        <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=1171-->)
                        the result will still always be an array. A view if no advanced index
                        is present, otherwise a copy.
                      </p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1167-->当省略号（<code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">...</span></code><!--volctrans extension anchor for patchId=1169-->）存在，但没有尺寸（即替换零
                        <code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">:</span></code><!--volctrans extension anchor for patchId=1171-->）结果仍然是一个数组。如果没有高级索引，则为视图，否则为副本。
                      </p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1174-->The <code
                          class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">nonzero</span></code><!--volctrans extension anchor for patchId=1176-->
                        equivalence for Boolean arrays does not hold for zero
                        dimensional boolean arrays.</p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1174-->布尔数组的<code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">nonzero</span></code><!--volctrans extension anchor for patchId=1176-->等价不适用于零维布尔数组。</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1179-->When the result of an
                        advanced indexing operation has no elements but an
                        individual index is out of bounds, whether or not an <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">IndexError</span></code><!--volctrans extension anchor for patchId=1181-->
                        is
                        raised is undefined (e.g. <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">x[[],</span> <span class="pre">[123]]</span></code><!--volctrans extension anchor for patchId=1183-->
                        with <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">123</span></code><!--volctrans extension anchor for patchId=1185-->
                        being out of bounds).</p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1179-->当高级索引操作的结果没有元素，但单个索引越界时，是否引发<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">IndexError</span></code><!--volctrans extension anchor for patchId=1181-->是不确定的（例如<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">x[[],</span> <span class="pre">[123]]</span></code><!--volctrans extension anchor for patchId=1183-->，其中<code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">123</span></code><!--volctrans extension anchor for patchId=1185-->是越界的）。
                      </p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1188-->When a <em
                          mt_node="origin_leaf">casting</em><!--volctrans extension anchor for patchId=1190--> error
                        occurs during assignment (for example updating a
                        numerical array using a sequence of strings), the array being assigned
                        to may end up in an unpredictable partially updated state.
                        However, if any other error (such as an out of bounds index) occurs, the
                        array will remain unchanged.</p>
                      <p mt_node="trans">
                        当在赋值期间发生类型转换错误（例如，使用字符串序列更新数值数组）时，被赋值的数组可能最终处于不可预测的部分更新状态。但是，如果出现任何其他错误（例如越界索引），数组将保持不变。</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf">The memory layout of an advanced indexing result is optimized for each
                        indexing operation and no particular memory order can be assumed.</p>
                      <p mt_node="trans">高级索引结果的内存布局针对每个索引操作进行了优化，不能假定任何特定的内存顺序。</p>
                    </li>
                    <li mt_node="origin">
                      <p mt_node="origin_leaf"><!--volctrans extension anchor for patchId=1195-->When using a subclass
                        (especially one which manipulates its shape), the
                        default <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ndarray.__setitem__</span></code><!--volctrans extension anchor for patchId=1197-->
                        behaviour will call <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">__getitem__</span></code><!--volctrans extension anchor for patchId=1199-->
                        for
                        <em mt_node="origin_leaf">basic</em><!--volctrans extension anchor for patchId=1201--> indexing
                        but not for <em
                          mt_node="origin_leaf">advanced</em><!--volctrans extension anchor for patchId=1203-->
                        indexing. For such a subclass it may
                        be preferable to call <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">ndarray.__setitem__</span></code><!--volctrans extension anchor for patchId=1205-->
                        with a <em mt_node="origin_leaf">base
                          class</em><!--volctrans extension anchor for patchId=1207--> ndarray
                        view on the data. This <em
                          mt_node="origin_leaf">must</em><!--volctrans extension anchor for patchId=1209--> be done if
                        the subclasses <code class="docutils literal notranslate"
                          mt_node="origin_leaf"><span class="pre">__getitem__</span></code><!--volctrans extension anchor for patchId=1211-->
                        does
                        not return views.
                      </p>
                      <p mt_node="trans"><!--volctrans extension anchor for patchId=1195-->当使用子类（尤其是操纵其形状的子类）时，
                        默认<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">ndarray.__setitem__</span></code><!--volctrans extension anchor for patchId=1197-->行为将调用<code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">__getitem__</span></code><!--volctrans extension anchor for patchId=1199-->
                          进行<em mt_node="trans">基本</em><!--volctrans extension anchor for patchId=1201-->索引，但这种情况不适用于<em
                          mt_node="trans">高级</em><!--volctrans extension anchor for patchId=1203-->索引。对于这样的子类，最好使用<em
                          mt_node="trans">基类</em><!--volctrans extension anchor for patchId=1207-->ndarray视图调用<code class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">ndarray.__setitem__</span></code><!--volctrans extension anchor for patchId=1205-->来访问数据。如果子类的<!--volctrans extension anchor for patchId=1209--><code
                          class="docutils literal notranslate"
                          mt_node="trans"><span class="pre">__getitem__</span></code>不返回视图，则必须这样做。
                      </p>
                    </li>
                  </ul>
                </section>
              </section>

            </article>

          </div>
        </div>

      </main>
    </div>
  </div>
</body>

</html>