import numpy as np
# 误差反向传播法 - 激活函数层的实现

# ReLU层
# 如果正向传播时，输入到ReLU函数内的x大于0，则在反向传播时会将上游的值原封不动地传给下游。反过来，如果正向传播时，输入到ReLU函数内的x小于等于0，则在反向传播中传给下游的信号将停在此处
# 反向传播时，y关于x的导数，x大于0时，y关于x的导数是1，这就是上面那个所谓的“在反向传播中会将上游传来的值原封不动地传给下游”，因为是乘1，被乘后，被乘的参数没有不变，所以也就给咱们一种错觉，以为是原封不动的传给下一个。
# 反向传播时，y关于x的导数，x小于等于0时，y关于x的导数是0，这就是上面所谓的“在反向传播中传给下游的信号将停在此处（传进来的参数将不会在往下传）”，因为是乘0，参数乘0后，也就变成0了，传给下一个参数，下一个参数也会变成0，也就给咱们一种错觉，以为停在此处了
# 不懂为啥 y关于x的导数，x大于0时，y关于x的导数是1 的话，看“导数那个文章”“为什么y=x²的导函数为y=2x”，它们也都是经过类似的处理，然后变成了（y关于x的导数，x大于0时，y关于x的导数是1）等等
class Relu:
    def __init__(self):
        self.mask = None

    def forward(self, x):
        self.mask = (x <= 0)
        out = x.copy()#因为是numpy数组，所以这个copy类似于js里的深拷贝
        out[self.mask] = 0
        return out
    def backward(self, dout):
        dout[self.mask] = 0
        dx = dout

        return dx

x = np.array([[1.0,-0.5],[-2.0,3.0]])
print(x)
'''
[[ 1.  -0.5]
 [-2.   3. ]]
'''
mask = (x<=0)
print(mask)
'''
[[False  True]
 [ True False]]
'''

# Sigmoid层
# 正向传播，看那个，图5-19，的sigmoid层的计算图，虽然分了好几个小步骤，但你一看就会明白，很正常的计算流程，看不懂的话，多点耐心，别急于求成
# 反向传播：
# 但反向传播时，稍稍有点小复杂，分了好几个小步骤，这几个步骤就是，正向传播时的顺序，反过来的顺序
# 1、反向传播第一步，“/”除号节点，此步在正向传播时，公式是如下式子，z=1/x，此步是正向传播时的，最后一个步
# 此步z关于x的导函数为-z²
# 2、反向传播第二步，“+”加号节点，此步在正向传播时，公式是如下式子，z=1+exp(−x)，此步是正向传播时的，倒数第二步
# 此步z关于x的导数为1（因为“+”节点将上游的值原封不动地传给下游，所这步的，z关于x的导函数解析性为1，不懂看demo5/index.py）
# 3、反向传播第三步，“exp”节点，此步在正向传播时，公式是如下式子，z=exp(x)，此步是正向传播时的，倒数第三步
# 此步z关于x的导数为exp(x)，哈哈，还是exp(x)，和正向传播时一样
# 4、反向传播第四步，“*”乘号节点，此步在正向传播时，公式是如下式子，z=-1*x，此步是正向传播时的，倒数第四步
# 此步z关于x的导数为-1，还记得上一个文件里demo5/index.py 乘号节点反向传播时，翻转正向传播时的x与y，忘了的话，重新看一遍，看一遍你就会明白，真的，不骗你
# 正向传播时的公式，y=sigmoid(x)。那y关于x的导函数是啥，其实这个结果就是上面这四小步，融合在一块，就是Sigmoid函数的反向传播
# 最终，y=sigmoid(x)，y关于x的导函数是 y(1-y)

# 书上原话，可以不用在意Sigmoid层中琐碎的细节，而只需要专注它的输入和输出就行，不懂的话就多重温几遍，你肯定会明白的，相信你，康先生

class Sigmoid:
    def __init__(self):
        self.out = None
    def forward(self,x):
        out = 1 / (1+np.exp(-x))
        self.out = out
        return out
    def backward(self,dout):
        dx = dout * (1.0-self.out) * self.out
        return dx




